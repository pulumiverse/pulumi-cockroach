# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['LogExportConfigArgs', 'LogExportConfig']

@pulumi.input_type
class LogExportConfigArgs:
    def __init__(__self__, *,
                 auth_principal: pulumi.Input[str],
                 cluster_id: pulumi.Input[str],
                 log_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]] = None,
                 omitted_channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 redact: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a LogExportConfig resource.
        :param pulumi.Input[str] auth_principal: Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP
               Project ID that the cluster service account has permissions to write to for cloud logging.
        :param pulumi.Input[str] cluster_id: Cluster ID.
        :param pulumi.Input[str] log_name: An identifier for the logs in the customer's log sink.
        :param pulumi.Input[str] type: The cloud selection being exported to along with the cloud logging platform. Possible values are: * AWS_CLOUDWATCH *
               GCP_CLOUD_LOGGING
        :param pulumi.Input[Sequence[pulumi.Input[str]]] omitted_channels: Controls what CRDB channels do not get exported.
        :param pulumi.Input[bool] redact: Controls whether logs are redacted before forwarding to customer sinks.
        :param pulumi.Input[str] region: Controls whether all logs are sent to a specific region in the customer sink.
        """
        pulumi.set(__self__, "auth_principal", auth_principal)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "log_name", log_name)
        pulumi.set(__self__, "type", type)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if omitted_channels is not None:
            pulumi.set(__self__, "omitted_channels", omitted_channels)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> pulumi.Input[str]:
        """
        Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP
        Project ID that the cluster service account has permissions to write to for cloud logging.
        """
        return pulumi.get(self, "auth_principal")

    @auth_principal.setter
    def auth_principal(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_principal", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[str]:
        """
        Cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> pulumi.Input[str]:
        """
        An identifier for the logs in the customer's log sink.
        """
        return pulumi.get(self, "log_name")

    @log_name.setter
    def log_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The cloud selection being exported to along with the cloud logging platform. Possible values are: * AWS_CLOUDWATCH *
        GCP_CLOUD_LOGGING
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="omittedChannels")
    def omitted_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Controls what CRDB channels do not get exported.
        """
        return pulumi.get(self, "omitted_channels")

    @omitted_channels.setter
    def omitted_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "omitted_channels", value)

    @property
    @pulumi.getter
    def redact(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether logs are redacted before forwarding to customer sinks.
        """
        return pulumi.get(self, "redact")

    @redact.setter
    def redact(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redact", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Controls whether all logs are sent to a specific region in the customer sink.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class _LogExportConfigState:
    def __init__(__self__, *,
                 auth_principal: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]] = None,
                 log_name: Optional[pulumi.Input[str]] = None,
                 omitted_channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 redact: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None,
                 user_message: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering LogExportConfig resources.
        :param pulumi.Input[str] auth_principal: Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP
               Project ID that the cluster service account has permissions to write to for cloud logging.
        :param pulumi.Input[str] cluster_id: Cluster ID.
        :param pulumi.Input[str] created_at: Indicates when log export was initially configured.
        :param pulumi.Input[str] log_name: An identifier for the logs in the customer's log sink.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] omitted_channels: Controls what CRDB channels do not get exported.
        :param pulumi.Input[bool] redact: Controls whether logs are redacted before forwarding to customer sinks.
        :param pulumi.Input[str] region: Controls whether all logs are sent to a specific region in the customer sink.
        :param pulumi.Input[str] status: Encodes the possible states that a log export configuration can be in as it is created, deployed, and disabled.
        :param pulumi.Input[str] type: The cloud selection being exported to along with the cloud logging platform. Possible values are: * AWS_CLOUDWATCH *
               GCP_CLOUD_LOGGING
        :param pulumi.Input[str] updated_at: Indicates when the log export configuration was last updated.
        :param pulumi.Input[str] user_message: Elaborates on the log export status and hints at how to fix issues that may have occurred during asynchronous
               operations.
        """
        if auth_principal is not None:
            pulumi.set(__self__, "auth_principal", auth_principal)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if log_name is not None:
            pulumi.set(__self__, "log_name", log_name)
        if omitted_channels is not None:
            pulumi.set(__self__, "omitted_channels", omitted_channels)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_message is not None:
            pulumi.set(__self__, "user_message", user_message)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> Optional[pulumi.Input[str]]:
        """
        Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP
        Project ID that the cluster service account has permissions to write to for cloud logging.
        """
        return pulumi.get(self, "auth_principal")

    @auth_principal.setter
    def auth_principal(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_principal", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates when log export was initially configured.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogExportConfigGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> Optional[pulumi.Input[str]]:
        """
        An identifier for the logs in the customer's log sink.
        """
        return pulumi.get(self, "log_name")

    @log_name.setter
    def log_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_name", value)

    @property
    @pulumi.getter(name="omittedChannels")
    def omitted_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Controls what CRDB channels do not get exported.
        """
        return pulumi.get(self, "omitted_channels")

    @omitted_channels.setter
    def omitted_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "omitted_channels", value)

    @property
    @pulumi.getter
    def redact(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether logs are redacted before forwarding to customer sinks.
        """
        return pulumi.get(self, "redact")

    @redact.setter
    def redact(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redact", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Controls whether all logs are sent to a specific region in the customer sink.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Encodes the possible states that a log export configuration can be in as it is created, deployed, and disabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The cloud selection being exported to along with the cloud logging platform. Possible values are: * AWS_CLOUDWATCH *
        GCP_CLOUD_LOGGING
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates when the log export configuration was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="userMessage")
    def user_message(self) -> Optional[pulumi.Input[str]]:
        """
        Elaborates on the log export status and hints at how to fix issues that may have occurred during asynchronous
        operations.
        """
        return pulumi.get(self, "user_message")

    @user_message.setter
    def user_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_message", value)


class LogExportConfig(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 auth_principal: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LogExportConfigGroupArgs']]]]] = None,
                 log_name: Optional[pulumi.Input[str]] = None,
                 omitted_channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 redact: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Log Export configuration for a cluster.

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] auth_principal: Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP
               Project ID that the cluster service account has permissions to write to for cloud logging.
        :param pulumi.Input[str] cluster_id: Cluster ID.
        :param pulumi.Input[str] log_name: An identifier for the logs in the customer's log sink.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] omitted_channels: Controls what CRDB channels do not get exported.
        :param pulumi.Input[bool] redact: Controls whether logs are redacted before forwarding to customer sinks.
        :param pulumi.Input[str] region: Controls whether all logs are sent to a specific region in the customer sink.
        :param pulumi.Input[str] type: The cloud selection being exported to along with the cloud logging platform. Possible values are: * AWS_CLOUDWATCH *
               GCP_CLOUD_LOGGING
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: LogExportConfigArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Log Export configuration for a cluster.

        :param str resource_name: The name of the resource.
        :param LogExportConfigArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(LogExportConfigArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 auth_principal: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LogExportConfigGroupArgs']]]]] = None,
                 log_name: Optional[pulumi.Input[str]] = None,
                 omitted_channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 redact: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = LogExportConfigArgs.__new__(LogExportConfigArgs)

            if auth_principal is None and not opts.urn:
                raise TypeError("Missing required property 'auth_principal'")
            __props__.__dict__["auth_principal"] = auth_principal
            if cluster_id is None and not opts.urn:
                raise TypeError("Missing required property 'cluster_id'")
            __props__.__dict__["cluster_id"] = cluster_id
            __props__.__dict__["groups"] = groups
            if log_name is None and not opts.urn:
                raise TypeError("Missing required property 'log_name'")
            __props__.__dict__["log_name"] = log_name
            __props__.__dict__["omitted_channels"] = omitted_channels
            __props__.__dict__["redact"] = redact
            __props__.__dict__["region"] = region
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
            __props__.__dict__["created_at"] = None
            __props__.__dict__["status"] = None
            __props__.__dict__["updated_at"] = None
            __props__.__dict__["user_message"] = None
        super(LogExportConfig, __self__).__init__(
            'cockroach:index/logExportConfig:LogExportConfig',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            auth_principal: Optional[pulumi.Input[str]] = None,
            cluster_id: Optional[pulumi.Input[str]] = None,
            created_at: Optional[pulumi.Input[str]] = None,
            groups: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['LogExportConfigGroupArgs']]]]] = None,
            log_name: Optional[pulumi.Input[str]] = None,
            omitted_channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            redact: Optional[pulumi.Input[bool]] = None,
            region: Optional[pulumi.Input[str]] = None,
            status: Optional[pulumi.Input[str]] = None,
            type: Optional[pulumi.Input[str]] = None,
            updated_at: Optional[pulumi.Input[str]] = None,
            user_message: Optional[pulumi.Input[str]] = None) -> 'LogExportConfig':
        """
        Get an existing LogExportConfig resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] auth_principal: Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP
               Project ID that the cluster service account has permissions to write to for cloud logging.
        :param pulumi.Input[str] cluster_id: Cluster ID.
        :param pulumi.Input[str] created_at: Indicates when log export was initially configured.
        :param pulumi.Input[str] log_name: An identifier for the logs in the customer's log sink.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] omitted_channels: Controls what CRDB channels do not get exported.
        :param pulumi.Input[bool] redact: Controls whether logs are redacted before forwarding to customer sinks.
        :param pulumi.Input[str] region: Controls whether all logs are sent to a specific region in the customer sink.
        :param pulumi.Input[str] status: Encodes the possible states that a log export configuration can be in as it is created, deployed, and disabled.
        :param pulumi.Input[str] type: The cloud selection being exported to along with the cloud logging platform. Possible values are: * AWS_CLOUDWATCH *
               GCP_CLOUD_LOGGING
        :param pulumi.Input[str] updated_at: Indicates when the log export configuration was last updated.
        :param pulumi.Input[str] user_message: Elaborates on the log export status and hints at how to fix issues that may have occurred during asynchronous
               operations.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _LogExportConfigState.__new__(_LogExportConfigState)

        __props__.__dict__["auth_principal"] = auth_principal
        __props__.__dict__["cluster_id"] = cluster_id
        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["groups"] = groups
        __props__.__dict__["log_name"] = log_name
        __props__.__dict__["omitted_channels"] = omitted_channels
        __props__.__dict__["redact"] = redact
        __props__.__dict__["region"] = region
        __props__.__dict__["status"] = status
        __props__.__dict__["type"] = type
        __props__.__dict__["updated_at"] = updated_at
        __props__.__dict__["user_message"] = user_message
        return LogExportConfig(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> pulumi.Output[str]:
        """
        Either the AWS Role ARN that identifies a role that the cluster account can assume to write to CloudWatch or the GCP
        Project ID that the cluster service account has permissions to write to for cloud logging.
        """
        return pulumi.get(self, "auth_principal")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Output[str]:
        """
        Cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[str]:
        """
        Indicates when log export was initially configured.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output[Optional[Sequence['outputs.LogExportConfigGroup']]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> pulumi.Output[str]:
        """
        An identifier for the logs in the customer's log sink.
        """
        return pulumi.get(self, "log_name")

    @property
    @pulumi.getter(name="omittedChannels")
    def omitted_channels(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        Controls what CRDB channels do not get exported.
        """
        return pulumi.get(self, "omitted_channels")

    @property
    @pulumi.getter
    def redact(self) -> pulumi.Output[Optional[bool]]:
        """
        Controls whether logs are redacted before forwarding to customer sinks.
        """
        return pulumi.get(self, "redact")

    @property
    @pulumi.getter
    def region(self) -> pulumi.Output[str]:
        """
        Controls whether all logs are sent to a specific region in the customer sink.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> pulumi.Output[str]:
        """
        Encodes the possible states that a log export configuration can be in as it is created, deployed, and disabled.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        """
        The cloud selection being exported to along with the cloud logging platform. Possible values are: * AWS_CLOUDWATCH *
        GCP_CLOUD_LOGGING
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> pulumi.Output[str]:
        """
        Indicates when the log export configuration was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="userMessage")
    def user_message(self) -> pulumi.Output[str]:
        """
        Elaborates on the log export status and hints at how to fix issues that may have occurred during asynchronous
        operations.
        """
        return pulumi.get(self, "user_message")

