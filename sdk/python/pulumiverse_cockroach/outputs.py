# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ClusterBackupConfig',
    'ClusterDedicated',
    'ClusterRegion',
    'ClusterServerless',
    'ClusterServerlessUsageLimits',
    'CmekAdditionalRegion',
    'CmekRegion',
    'CmekRegionKey',
    'JwtIssuerIdentityMap',
    'LogExportConfigGroup',
    'PrivateEndpointServicesService',
    'PrivateEndpointServicesServiceAws',
    'PrivateEndpointServicesServicesMap',
    'PrivateEndpointServicesServicesMapAws',
    'UserRoleGrantRole',
    'UserRoleGrantsRole',
    'GetCockroachClusterBackupConfigResult',
    'GetCockroachClusterDedicatedResult',
    'GetCockroachClusterRegionResult',
    'GetCockroachClusterServerlessResult',
    'GetCockroachClusterServerlessUsageLimitsResult',
    'GetConnectionStringConnectionParamsResult',
]

@pulumi.output_type
class ClusterBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyMinutes":
            suggest = "frequency_minutes"
        elif key == "retentionDays":
            suggest = "retention_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 frequency_minutes: Optional[int] = None,
                 retention_days: Optional[int] = None):
        """
        :param bool enabled: Indicates whether backups are enabled. If set to false, no backups will be created.
        :param int frequency_minutes: The frequency of backups in minutes.  Valid values are [5, 10, 15, 30, 60, 240, 1440]
        :param int retention_days: The number of days to retain backups for.  Valid values are [2, 7, 30, 90, 365]. Can only be set once, further changes require opening a support ticket. See Updating backup retention for more information.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if frequency_minutes is not None:
            pulumi.set(__self__, "frequency_minutes", frequency_minutes)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether backups are enabled. If set to false, no backups will be created.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="frequencyMinutes")
    def frequency_minutes(self) -> Optional[int]:
        """
        The frequency of backups in minutes.  Valid values are [5, 10, 15, 30, 60, 240, 1440]
        """
        return pulumi.get(self, "frequency_minutes")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[int]:
        """
        The number of days to retain backups for.  Valid values are [2, 7, 30, 90, 365]. Can only be set once, further changes require opening a support ticket. See Updating backup retention for more information.
        """
        return pulumi.get(self, "retention_days")


@pulumi.output_type
class ClusterDedicated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrRange":
            suggest = "cidr_range"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "memoryGib":
            suggest = "memory_gib"
        elif key == "numVirtualCpus":
            suggest = "num_virtual_cpus"
        elif key == "privateNetworkVisibility":
            suggest = "private_network_visibility"
        elif key == "storageGib":
            suggest = "storage_gib"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDedicated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDedicated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDedicated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_range: Optional[str] = None,
                 disk_iops: Optional[int] = None,
                 machine_type: Optional[str] = None,
                 memory_gib: Optional[float] = None,
                 num_virtual_cpus: Optional[int] = None,
                 private_network_visibility: Optional[bool] = None,
                 storage_gib: Optional[int] = None):
        """
        :param str cidr_range: The IPv4 range in CIDR format that will be used by the cluster. This is supported only on GCP, and must have a subnet mask no larger than /19. Defaults to "172.28.0.0/14". This cannot be changed after cluster creation.
        :param int disk_iops: Number of disk I/O operations per second that are permitted on each node in the cluster. Omitting this attribute will result in the cloud provider-specific default.
        :param str machine_type: Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4. This attribute requires a feature flag to be enabled. It is recommended to leave this empty and use `num_virtual_cpus` to control the machine type.
        :param float memory_gib: Memory per node in GiB.
        :param int num_virtual_cpus: Number of virtual CPUs per node in the cluster.
        :param bool private_network_visibility: Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features. Clusters created with this flag will have advanced security features enabled.  This cannot be changed after cluster creation and incurs additional charges.  See [Create an Advanced Cluster](https://www.cockroachlabs.com/docs/cockroachcloud/create-an-advanced-cluster.html#step-6-configure-advanced-security-features) and [Pricing](https://www.cockroachlabs.com/pricing/) for more information.
        :param int storage_gib: Storage amount per node in GiB.
        """
        if cidr_range is not None:
            pulumi.set(__self__, "cidr_range", cidr_range)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if memory_gib is not None:
            pulumi.set(__self__, "memory_gib", memory_gib)
        if num_virtual_cpus is not None:
            pulumi.set(__self__, "num_virtual_cpus", num_virtual_cpus)
        if private_network_visibility is not None:
            pulumi.set(__self__, "private_network_visibility", private_network_visibility)
        if storage_gib is not None:
            pulumi.set(__self__, "storage_gib", storage_gib)

    @property
    @pulumi.getter(name="cidrRange")
    def cidr_range(self) -> Optional[str]:
        """
        The IPv4 range in CIDR format that will be used by the cluster. This is supported only on GCP, and must have a subnet mask no larger than /19. Defaults to "172.28.0.0/14". This cannot be changed after cluster creation.
        """
        return pulumi.get(self, "cidr_range")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Number of disk I/O operations per second that are permitted on each node in the cluster. Omitting this attribute will result in the cloud provider-specific default.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[str]:
        """
        Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4. This attribute requires a feature flag to be enabled. It is recommended to leave this empty and use `num_virtual_cpus` to control the machine type.
        """
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> Optional[float]:
        """
        Memory per node in GiB.
        """
        return pulumi.get(self, "memory_gib")

    @property
    @pulumi.getter(name="numVirtualCpus")
    def num_virtual_cpus(self) -> Optional[int]:
        """
        Number of virtual CPUs per node in the cluster.
        """
        return pulumi.get(self, "num_virtual_cpus")

    @property
    @pulumi.getter(name="privateNetworkVisibility")
    def private_network_visibility(self) -> Optional[bool]:
        """
        Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features. Clusters created with this flag will have advanced security features enabled.  This cannot be changed after cluster creation and incurs additional charges.  See [Create an Advanced Cluster](https://www.cockroachlabs.com/docs/cockroachcloud/create-an-advanced-cluster.html#step-6-configure-advanced-security-features) and [Pricing](https://www.cockroachlabs.com/pricing/) for more information.
        """
        return pulumi.get(self, "private_network_visibility")

    @property
    @pulumi.getter(name="storageGib")
    def storage_gib(self) -> Optional[int]:
        """
        Storage amount per node in GiB.
        """
        return pulumi.get(self, "storage_gib")


@pulumi.output_type
class ClusterRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalDns":
            suggest = "internal_dns"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "sqlDns":
            suggest = "sql_dns"
        elif key == "uiDns":
            suggest = "ui_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 internal_dns: Optional[str] = None,
                 node_count: Optional[int] = None,
                 primary: Optional[bool] = None,
                 sql_dns: Optional[str] = None,
                 ui_dns: Optional[str] = None):
        """
        :param str name: Name of the region. Should match the region code used by the cluster's cloud provider.
        :param str internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param int node_count: Number of nodes in the region. Valid for Advanced clusters only.
        :param bool primary: Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        :param str sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param str ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "name", name)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if sql_dns is not None:
            pulumi.set(__self__, "sql_dns", sql_dns)
        if ui_dns is not None:
            pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[str]:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes in the region. Valid for Advanced clusters only.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> Optional[str]:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> Optional[str]:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")


@pulumi.output_type
class ClusterServerless(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingId":
            suggest = "routing_id"
        elif key == "spendLimit":
            suggest = "spend_limit"
        elif key == "upgradeType":
            suggest = "upgrade_type"
        elif key == "usageLimits":
            suggest = "usage_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServerless. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServerless.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServerless.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 routing_id: Optional[str] = None,
                 spend_limit: Optional[int] = None,
                 upgrade_type: Optional[str] = None,
                 usage_limits: Optional['outputs.ClusterServerlessUsageLimits'] = None):
        """
        :param str routing_id: Cluster identifier in a connection string.
        :param int spend_limit: Spend limit in US cents.
        :param str upgrade_type: Dictates the behavior of CockroachDB major version upgrades. Manual upgrades are not supported on CockroachDB Basic. Manual or automatic upgrades are supported on CockroachDB Standard. If you omit the field, it defaults to `AUTOMATIC`. Allowed values are:
                 * MANUAL
                 * AUTOMATIC
        """
        if routing_id is not None:
            pulumi.set(__self__, "routing_id", routing_id)
        if spend_limit is not None:
            pulumi.set(__self__, "spend_limit", spend_limit)
        if upgrade_type is not None:
            pulumi.set(__self__, "upgrade_type", upgrade_type)
        if usage_limits is not None:
            pulumi.set(__self__, "usage_limits", usage_limits)

    @property
    @pulumi.getter(name="routingId")
    def routing_id(self) -> Optional[str]:
        """
        Cluster identifier in a connection string.
        """
        return pulumi.get(self, "routing_id")

    @property
    @pulumi.getter(name="spendLimit")
    @_utilities.deprecated("""The `spend_limit` attribute is deprecated and will be removed in a future release of the provider. Configure 'usage_limits' instead.""")
    def spend_limit(self) -> Optional[int]:
        """
        Spend limit in US cents.
        """
        return pulumi.get(self, "spend_limit")

    @property
    @pulumi.getter(name="upgradeType")
    def upgrade_type(self) -> Optional[str]:
        """
        Dictates the behavior of CockroachDB major version upgrades. Manual upgrades are not supported on CockroachDB Basic. Manual or automatic upgrades are supported on CockroachDB Standard. If you omit the field, it defaults to `AUTOMATIC`. Allowed values are:
          * MANUAL
          * AUTOMATIC
        """
        return pulumi.get(self, "upgrade_type")

    @property
    @pulumi.getter(name="usageLimits")
    def usage_limits(self) -> Optional['outputs.ClusterServerlessUsageLimits']:
        return pulumi.get(self, "usage_limits")


@pulumi.output_type
class ClusterServerlessUsageLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisionedVirtualCpus":
            suggest = "provisioned_virtual_cpus"
        elif key == "requestUnitLimit":
            suggest = "request_unit_limit"
        elif key == "storageMibLimit":
            suggest = "storage_mib_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServerlessUsageLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServerlessUsageLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServerlessUsageLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioned_virtual_cpus: Optional[int] = None,
                 request_unit_limit: Optional[int] = None,
                 storage_mib_limit: Optional[int] = None):
        """
        :param int provisioned_virtual_cpus: Maximum number of vCPUs that the cluster can use.
        :param int request_unit_limit: Maximum number of Request Units that the cluster can consume during the month.
        :param int storage_mib_limit: Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        if provisioned_virtual_cpus is not None:
            pulumi.set(__self__, "provisioned_virtual_cpus", provisioned_virtual_cpus)
        if request_unit_limit is not None:
            pulumi.set(__self__, "request_unit_limit", request_unit_limit)
        if storage_mib_limit is not None:
            pulumi.set(__self__, "storage_mib_limit", storage_mib_limit)

    @property
    @pulumi.getter(name="provisionedVirtualCpus")
    def provisioned_virtual_cpus(self) -> Optional[int]:
        """
        Maximum number of vCPUs that the cluster can use.
        """
        return pulumi.get(self, "provisioned_virtual_cpus")

    @property
    @pulumi.getter(name="requestUnitLimit")
    def request_unit_limit(self) -> Optional[int]:
        """
        Maximum number of Request Units that the cluster can consume during the month.
        """
        return pulumi.get(self, "request_unit_limit")

    @property
    @pulumi.getter(name="storageMibLimit")
    def storage_mib_limit(self) -> Optional[int]:
        """
        Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        return pulumi.get(self, "storage_mib_limit")


@pulumi.output_type
class CmekAdditionalRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalDns":
            suggest = "internal_dns"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "sqlDns":
            suggest = "sql_dns"
        elif key == "uiDns":
            suggest = "ui_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmekAdditionalRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmekAdditionalRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmekAdditionalRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 internal_dns: Optional[str] = None,
                 node_count: Optional[int] = None,
                 primary: Optional[bool] = None,
                 sql_dns: Optional[str] = None,
                 ui_dns: Optional[str] = None):
        """
        :param str name: Name of the region. Should match the region code used by the cluster's cloud provider.
        :param str internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param int node_count: Number of nodes in the region. Valid for Advanced clusters only.
        :param bool primary: Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        :param str sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param str ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "name", name)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if sql_dns is not None:
            pulumi.set(__self__, "sql_dns", sql_dns)
        if ui_dns is not None:
            pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[str]:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes in the region. Valid for Advanced clusters only.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> Optional[str]:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> Optional[str]:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")


@pulumi.output_type
class CmekRegion(dict):
    def __init__(__self__, *,
                 key: 'outputs.CmekRegionKey',
                 region: str,
                 status: Optional[str] = None):
        """
        :param str region: Cloud provider region code.
        :param str status: Describes the status of the current encryption key within the region.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def key(self) -> 'outputs.CmekRegionKey':
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Cloud provider region code.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Describes the status of the current encryption key within the region.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CmekRegionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authPrincipal":
            suggest = "auth_principal"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "userMessage":
            suggest = "user_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmekRegionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmekRegionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmekRegionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_principal: str,
                 type: str,
                 uri: str,
                 created_at: Optional[str] = None,
                 status: Optional[str] = None,
                 updated_at: Optional[str] = None,
                 user_message: Optional[str] = None):
        """
        :param str auth_principal: Principal to authenticate as in order to access the key.
        :param str type: Type of encryption key. Current allowed values are:
                 * AWS_KMS
                 * GCP_CLOUD_KMS
                 * NULL_KMS
        :param str uri: Provider-specific URI pointing to the encryption key.
        :param str created_at: Indicates when the key was created.
        :param str status: Current status of this key.
        :param str updated_at: Indicates when the key was last updated.
        :param str user_message: Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
        pulumi.set(__self__, "auth_principal", auth_principal)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_message is not None:
            pulumi.set(__self__, "user_message", user_message)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> str:
        """
        Principal to authenticate as in order to access the key.
        """
        return pulumi.get(self, "auth_principal")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of encryption key. Current allowed values are:
          * AWS_KMS
          * GCP_CLOUD_KMS
          * NULL_KMS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Provider-specific URI pointing to the encryption key.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        Indicates when the key was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Current status of this key.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        Indicates when the key was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="userMessage")
    def user_message(self) -> Optional[str]:
        """
        Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
        return pulumi.get(self, "user_message")


@pulumi.output_type
class JwtIssuerIdentityMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ccIdentity":
            suggest = "cc_identity"
        elif key == "tokenIdentity":
            suggest = "token_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JwtIssuerIdentityMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JwtIssuerIdentityMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JwtIssuerIdentityMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cc_identity: str,
                 token_identity: str):
        """
        :param str cc_identity: Specifies how to map the fetched token identity to an identity in CockroachDB Cloud. In case of a regular expression for token_identity, this must contain a \\1 placeholder for the matched content. Note that you will need to escape the backslash in the string as in the example usage (\\\\1).
        :param str token_identity: Specifies how to fetch external identity from the token claim. A regular expression must start with a forward slash. The regular expression must be in RE2 compatible syntax. For further details, please see https://github.com/google/re2/wiki/Syntax.
        """
        pulumi.set(__self__, "cc_identity", cc_identity)
        pulumi.set(__self__, "token_identity", token_identity)

    @property
    @pulumi.getter(name="ccIdentity")
    def cc_identity(self) -> str:
        """
        Specifies how to map the fetched token identity to an identity in CockroachDB Cloud. In case of a regular expression for token_identity, this must contain a \\1 placeholder for the matched content. Note that you will need to escape the backslash in the string as in the example usage (\\\\1).
        """
        return pulumi.get(self, "cc_identity")

    @property
    @pulumi.getter(name="tokenIdentity")
    def token_identity(self) -> str:
        """
        Specifies how to fetch external identity from the token claim. A regular expression must start with a forward slash. The regular expression must be in RE2 compatible syntax. For further details, please see https://github.com/google/re2/wiki/Syntax.
        """
        return pulumi.get(self, "token_identity")


@pulumi.output_type
class LogExportConfigGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logName":
            suggest = "log_name"
        elif key == "minLevel":
            suggest = "min_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogExportConfigGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogExportConfigGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogExportConfigGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channels: Sequence[str],
                 log_name: str,
                 min_level: Optional[str] = None,
                 redact: Optional[bool] = None):
        """
        :param Sequence[str] channels: A list of CockroachDB log channels to include in this group.
        :param str log_name: The name of the group, reflected in the log sink.
        :param str min_level: The minimum log level to filter to this log group.
        :param bool redact: Governs whether this log group should aggregate redacted logs if unset.
        """
        pulumi.set(__self__, "channels", channels)
        pulumi.set(__self__, "log_name", log_name)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)

    @property
    @pulumi.getter
    def channels(self) -> Sequence[str]:
        """
        A list of CockroachDB log channels to include in this group.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> str:
        """
        The name of the group, reflected in the log sink.
        """
        return pulumi.get(self, "log_name")

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[str]:
        """
        The minimum log level to filter to this log group.
        """
        return pulumi.get(self, "min_level")

    @property
    @pulumi.getter
    def redact(self) -> Optional[bool]:
        """
        Governs whether this log group should aggregate redacted logs if unset.
        """
        return pulumi.get(self, "redact")


@pulumi.output_type
class PrivateEndpointServicesService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneIds":
            suggest = "availability_zone_ids"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "endpointServiceId":
            suggest = "endpoint_service_id"
        elif key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointServicesService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointServicesService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointServicesService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_ids: Optional[Sequence[str]] = None,
                 aws: Optional['outputs.PrivateEndpointServicesServiceAws'] = None,
                 cloud_provider: Optional[str] = None,
                 endpoint_service_id: Optional[str] = None,
                 name: Optional[str] = None,
                 region_name: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param Sequence[str] availability_zone_ids: Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        :param str cloud_provider: Cloud provider associated with this service.
        :param str endpoint_service_id: Server side ID of the private endpoint connection.
        :param str name: Name of the endpoint service.
        :param str region_name: Cloud provider region code associated with this service.
        :param str status: Operation status of the service.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if endpoint_service_id is not None:
            pulumi.set(__self__, "endpoint_service_id", endpoint_service_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[Sequence[str]]:
        """
        Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        """
        return pulumi.get(self, "availability_zone_ids")

    @property
    @pulumi.getter
    @_utilities.deprecated("""nested aws fields have been moved one level up. These fields will be removed in a future version""")
    def aws(self) -> Optional['outputs.PrivateEndpointServicesServiceAws']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Cloud provider associated with this service.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="endpointServiceId")
    def endpoint_service_id(self) -> Optional[str]:
        """
        Server side ID of the private endpoint connection.
        """
        return pulumi.get(self, "endpoint_service_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the endpoint service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        Cloud provider region code associated with this service.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Operation status of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PrivateEndpointServicesServiceAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneIds":
            suggest = "availability_zone_ids"
        elif key == "serviceId":
            suggest = "service_id"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointServicesServiceAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointServicesServiceAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointServicesServiceAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_ids: Optional[Sequence[str]] = None,
                 service_id: Optional[str] = None,
                 service_name: Optional[str] = None):
        """
        :param Sequence[str] availability_zone_ids: AZ IDs users should create their VPCs in to minimize their cost.
        :param str service_id: Server side ID of the PrivateLink connection.
        :param str service_name: AWS service name used to create endpoints.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[Sequence[str]]:
        """
        AZ IDs users should create their VPCs in to minimize their cost.
        """
        return pulumi.get(self, "availability_zone_ids")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[str]:
        """
        Server side ID of the PrivateLink connection.
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        AWS service name used to create endpoints.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class PrivateEndpointServicesServicesMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneIds":
            suggest = "availability_zone_ids"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "endpointServiceId":
            suggest = "endpoint_service_id"
        elif key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointServicesServicesMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointServicesServicesMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointServicesServicesMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_ids: Optional[Sequence[str]] = None,
                 aws: Optional['outputs.PrivateEndpointServicesServicesMapAws'] = None,
                 cloud_provider: Optional[str] = None,
                 endpoint_service_id: Optional[str] = None,
                 name: Optional[str] = None,
                 region_name: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param Sequence[str] availability_zone_ids: Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        :param str cloud_provider: Cloud provider associated with this service.
        :param str endpoint_service_id: Server side ID of the private endpoint connection.
        :param str name: Name of the endpoint service.
        :param str region_name: Cloud provider region code associated with this service.
        :param str status: Operation status of the service.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if endpoint_service_id is not None:
            pulumi.set(__self__, "endpoint_service_id", endpoint_service_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[Sequence[str]]:
        """
        Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        """
        return pulumi.get(self, "availability_zone_ids")

    @property
    @pulumi.getter
    @_utilities.deprecated("""nested aws fields have been moved one level up. These fields will be removed in a future version""")
    def aws(self) -> Optional['outputs.PrivateEndpointServicesServicesMapAws']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Cloud provider associated with this service.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="endpointServiceId")
    def endpoint_service_id(self) -> Optional[str]:
        """
        Server side ID of the private endpoint connection.
        """
        return pulumi.get(self, "endpoint_service_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the endpoint service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        Cloud provider region code associated with this service.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Operation status of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PrivateEndpointServicesServicesMapAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneIds":
            suggest = "availability_zone_ids"
        elif key == "serviceId":
            suggest = "service_id"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointServicesServicesMapAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointServicesServicesMapAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointServicesServicesMapAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_ids: Optional[Sequence[str]] = None,
                 service_id: Optional[str] = None,
                 service_name: Optional[str] = None):
        """
        :param Sequence[str] availability_zone_ids: AZ IDs users should create their VPCs in to minimize their cost.
        :param str service_id: Server side ID of the PrivateLink connection.
        :param str service_name: AWS service name used to create endpoints.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[Sequence[str]]:
        """
        AZ IDs users should create their VPCs in to minimize their cost.
        """
        return pulumi.get(self, "availability_zone_ids")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[str]:
        """
        Server side ID of the PrivateLink connection.
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        AWS service name used to create endpoints.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class UserRoleGrantRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserRoleGrantRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserRoleGrantRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserRoleGrantRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: str,
                 role_name: str,
                 resource_id: Optional[str] = None):
        """
        :param str resource_type: Type of resource. Allowed values are:
                 * ORGANIZATION
                 * CLUSTER
                 * FOLDER
        :param str role_name: Name of the role to grant. Allowed values are:
                 * BILLING_COORDINATOR
                 * ORG_ADMIN
                 * ORG_MEMBER
                 * CLUSTER_ADMIN
                 * CLUSTER_OPERATOR_WRITER
                 * CLUSTER_DEVELOPER
                 * CLUSTER_CREATOR
                 * FOLDER_ADMIN
                 * FOLDER_MOVER
        :param str resource_id: ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "role_name", role_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of resource. Allowed values are:
          * ORGANIZATION
          * CLUSTER
          * FOLDER
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the role to grant. Allowed values are:
          * BILLING_COORDINATOR
          * ORG_ADMIN
          * ORG_MEMBER
          * CLUSTER_ADMIN
          * CLUSTER_OPERATOR_WRITER
          * CLUSTER_DEVELOPER
          * CLUSTER_CREATOR
          * FOLDER_ADMIN
          * FOLDER_MOVER
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class UserRoleGrantsRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserRoleGrantsRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserRoleGrantsRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserRoleGrantsRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: str,
                 role_name: str,
                 resource_id: Optional[str] = None):
        """
        :param str resource_type: Type of resource. Allowed values are: 
                 * ORGANIZATION
                 * CLUSTER
                 * FOLDER
        :param str role_name: Name of the role to grant. Allowed values are:
                 * BILLING_COORDINATOR
                 * ORG_ADMIN
                 * ORG_MEMBER
                 * CLUSTER_ADMIN
                 * CLUSTER_OPERATOR_WRITER
                 * CLUSTER_DEVELOPER
                 * CLUSTER_CREATOR
                 * FOLDER_ADMIN
                 * FOLDER_MOVER
        :param str resource_id: ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "role_name", role_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of resource. Allowed values are: 
          * ORGANIZATION
          * CLUSTER
          * FOLDER
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the role to grant. Allowed values are:
          * BILLING_COORDINATOR
          * ORG_ADMIN
          * ORG_MEMBER
          * CLUSTER_ADMIN
          * CLUSTER_OPERATOR_WRITER
          * CLUSTER_DEVELOPER
          * CLUSTER_CREATOR
          * FOLDER_ADMIN
          * FOLDER_MOVER
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class GetCockroachClusterBackupConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 frequency_minutes: int,
                 retention_days: int):
        """
        :param bool enabled: Indicates whether backups are enabled.
        :param int frequency_minutes: The frequency of backups in minutes.
        :param int retention_days: The number of days to retain backups for.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "frequency_minutes", frequency_minutes)
        pulumi.set(__self__, "retention_days", retention_days)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether backups are enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="frequencyMinutes")
    def frequency_minutes(self) -> int:
        """
        The frequency of backups in minutes.
        """
        return pulumi.get(self, "frequency_minutes")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> int:
        """
        The number of days to retain backups for.
        """
        return pulumi.get(self, "retention_days")


@pulumi.output_type
class GetCockroachClusterDedicatedResult(dict):
    def __init__(__self__, *,
                 cidr_range: str,
                 disk_iops: int,
                 machine_type: str,
                 memory_gib: float,
                 num_virtual_cpus: int,
                 private_network_visibility: bool,
                 storage_gib: int):
        """
        :param str cidr_range: The IPv4 range in CIDR format that is in use by the cluster. It is only set on GCP clusters and is otherwise empty.
        :param int disk_iops: Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        :param str machine_type: Machine type identifier within the given cloud provider, ex. m6.xlarge, n2-standard-4.
        :param float memory_gib: Memory per node in GiB.
        :param int num_virtual_cpus: Number of virtual CPUs per node in the cluster.
        :param bool private_network_visibility: Indicates whether private IP addresses are assigned to nodes. Required for CMEK and other advanced networking features.
        :param int storage_gib: Storage amount per node in GiB.
        """
        pulumi.set(__self__, "cidr_range", cidr_range)
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "memory_gib", memory_gib)
        pulumi.set(__self__, "num_virtual_cpus", num_virtual_cpus)
        pulumi.set(__self__, "private_network_visibility", private_network_visibility)
        pulumi.set(__self__, "storage_gib", storage_gib)

    @property
    @pulumi.getter(name="cidrRange")
    def cidr_range(self) -> str:
        """
        The IPv4 range in CIDR format that is in use by the cluster. It is only set on GCP clusters and is otherwise empty.
        """
        return pulumi.get(self, "cidr_range")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> int:
        """
        Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        """
        Machine type identifier within the given cloud provider, ex. m6.xlarge, n2-standard-4.
        """
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> float:
        """
        Memory per node in GiB.
        """
        return pulumi.get(self, "memory_gib")

    @property
    @pulumi.getter(name="numVirtualCpus")
    def num_virtual_cpus(self) -> int:
        """
        Number of virtual CPUs per node in the cluster.
        """
        return pulumi.get(self, "num_virtual_cpus")

    @property
    @pulumi.getter(name="privateNetworkVisibility")
    def private_network_visibility(self) -> bool:
        """
        Indicates whether private IP addresses are assigned to nodes. Required for CMEK and other advanced networking features.
        """
        return pulumi.get(self, "private_network_visibility")

    @property
    @pulumi.getter(name="storageGib")
    def storage_gib(self) -> int:
        """
        Storage amount per node in GiB.
        """
        return pulumi.get(self, "storage_gib")


@pulumi.output_type
class GetCockroachClusterRegionResult(dict):
    def __init__(__self__, *,
                 internal_dns: str,
                 name: str,
                 node_count: int,
                 primary: bool,
                 sql_dns: str,
                 ui_dns: str):
        """
        :param str internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param str name: Region code used by the cluster's cloud provider.
        :param int node_count: Number of nodes in the region. Will always be 0 for serverless clusters.
        :param bool primary: Denotes whether this is the primary region in a serverless cluster. Dedicated clusters don't have a primary region.
        :param str sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param str ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "internal_dns", internal_dns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "sql_dns", sql_dns)
        pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> str:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        Denotes whether this is the primary region in a serverless cluster. Dedicated clusters don't have a primary region.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> str:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> str:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")


@pulumi.output_type
class GetCockroachClusterServerlessResult(dict):
    def __init__(__self__, *,
                 routing_id: str,
                 spend_limit: int,
                 upgrade_type: str,
                 usage_limits: 'outputs.GetCockroachClusterServerlessUsageLimitsResult'):
        """
        :param str routing_id: Cluster identifier in a connection string.
        :param int spend_limit: Spend limit in US cents.
        :param str upgrade_type: Dictates the behavior of CockroachDB major version upgrades.
        """
        pulumi.set(__self__, "routing_id", routing_id)
        pulumi.set(__self__, "spend_limit", spend_limit)
        pulumi.set(__self__, "upgrade_type", upgrade_type)
        pulumi.set(__self__, "usage_limits", usage_limits)

    @property
    @pulumi.getter(name="routingId")
    def routing_id(self) -> str:
        """
        Cluster identifier in a connection string.
        """
        return pulumi.get(self, "routing_id")

    @property
    @pulumi.getter(name="spendLimit")
    @_utilities.deprecated("""The `spend_limit` attribute is deprecated and will be removed in a future release of the provider. Configure 'usage_limits' instead.""")
    def spend_limit(self) -> int:
        """
        Spend limit in US cents.
        """
        return pulumi.get(self, "spend_limit")

    @property
    @pulumi.getter(name="upgradeType")
    def upgrade_type(self) -> str:
        """
        Dictates the behavior of CockroachDB major version upgrades.
        """
        return pulumi.get(self, "upgrade_type")

    @property
    @pulumi.getter(name="usageLimits")
    def usage_limits(self) -> 'outputs.GetCockroachClusterServerlessUsageLimitsResult':
        return pulumi.get(self, "usage_limits")


@pulumi.output_type
class GetCockroachClusterServerlessUsageLimitsResult(dict):
    def __init__(__self__, *,
                 provisioned_virtual_cpus: int,
                 request_unit_limit: int,
                 storage_mib_limit: int):
        """
        :param int provisioned_virtual_cpus: Maximum number of vCPUs that the cluster can use.
        :param int request_unit_limit: Maximum number of Request Units that the cluster can consume during the month.
        :param int storage_mib_limit: Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        pulumi.set(__self__, "provisioned_virtual_cpus", provisioned_virtual_cpus)
        pulumi.set(__self__, "request_unit_limit", request_unit_limit)
        pulumi.set(__self__, "storage_mib_limit", storage_mib_limit)

    @property
    @pulumi.getter(name="provisionedVirtualCpus")
    def provisioned_virtual_cpus(self) -> int:
        """
        Maximum number of vCPUs that the cluster can use.
        """
        return pulumi.get(self, "provisioned_virtual_cpus")

    @property
    @pulumi.getter(name="requestUnitLimit")
    def request_unit_limit(self) -> int:
        """
        Maximum number of Request Units that the cluster can consume during the month.
        """
        return pulumi.get(self, "request_unit_limit")

    @property
    @pulumi.getter(name="storageMibLimit")
    def storage_mib_limit(self) -> int:
        """
        Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        return pulumi.get(self, "storage_mib_limit")


@pulumi.output_type
class GetConnectionStringConnectionParamsResult(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 password: str,
                 port: str,
                 username: str):
        """
        :param str database: Database value to use in a connection URL.
        :param str host: Host value to use in a connection URL.
        :param str password: Password value to use in a connection URL.
        :param str port: Port value to use in a connection URL.
        :param str username: Username value to use in a connection URL.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database value to use in a connection URL.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host value to use in a connection URL.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password value to use in a connection URL.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Port value to use in a connection URL.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username value to use in a connection URL.
        """
        return pulumi.get(self, "username")


