# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ApiOidcConfigIdentityMap',
    'ClusterDedicated',
    'ClusterRegion',
    'ClusterServerless',
    'ClusterServerlessUsageLimits',
    'CmekAdditionalRegion',
    'CmekRegion',
    'CmekRegionKey',
    'LogExportConfigGroup',
    'PrivateEndpointServicesService',
    'PrivateEndpointServicesServiceAws',
    'UserRoleGrantsRole',
    'GetCockroachClusterDedicatedResult',
    'GetCockroachClusterRegionResult',
    'GetCockroachClusterServerlessResult',
    'GetCockroachClusterServerlessUsageLimitsResult',
    'GetConnectionStringConnectionParamsResult',
]

@pulumi.output_type
class ApiOidcConfigIdentityMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ccIdentity":
            suggest = "cc_identity"
        elif key == "tokenIdentity":
            suggest = "token_identity"
        elif key == "isRegex":
            suggest = "is_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiOidcConfigIdentityMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiOidcConfigIdentityMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiOidcConfigIdentityMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cc_identity: str,
                 token_identity: str,
                 is_regex: Optional[bool] = None):
        """
        :param str cc_identity: The username (email or service account id) of the CC user that the token should map to.
        :param str token_identity: The token value that needs to be mapped.
        :param bool is_regex: Indicates that the token_principal field is a regex value.
        """
        pulumi.set(__self__, "cc_identity", cc_identity)
        pulumi.set(__self__, "token_identity", token_identity)
        if is_regex is not None:
            pulumi.set(__self__, "is_regex", is_regex)

    @property
    @pulumi.getter(name="ccIdentity")
    def cc_identity(self) -> str:
        """
        The username (email or service account id) of the CC user that the token should map to.
        """
        return pulumi.get(self, "cc_identity")

    @property
    @pulumi.getter(name="tokenIdentity")
    def token_identity(self) -> str:
        """
        The token value that needs to be mapped.
        """
        return pulumi.get(self, "token_identity")

    @property
    @pulumi.getter(name="isRegex")
    def is_regex(self) -> Optional[bool]:
        """
        Indicates that the token_principal field is a regex value.
        """
        return pulumi.get(self, "is_regex")


@pulumi.output_type
class ClusterDedicated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskIops":
            suggest = "disk_iops"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "memoryGib":
            suggest = "memory_gib"
        elif key == "numVirtualCpus":
            suggest = "num_virtual_cpus"
        elif key == "privateNetworkVisibility":
            suggest = "private_network_visibility"
        elif key == "storageGib":
            suggest = "storage_gib"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDedicated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDedicated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDedicated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_iops: Optional[int] = None,
                 machine_type: Optional[str] = None,
                 memory_gib: Optional[float] = None,
                 num_virtual_cpus: Optional[int] = None,
                 private_network_visibility: Optional[bool] = None,
                 storage_gib: Optional[int] = None):
        """
        :param int disk_iops: Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        :param str machine_type: Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4.
        :param float memory_gib: Memory per node in GiB.
        :param int num_virtual_cpus: Number of virtual CPUs per node in the cluster.
        :param bool private_network_visibility: Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features.
        :param int storage_gib: Storage amount per node in GiB.
        """
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if memory_gib is not None:
            pulumi.set(__self__, "memory_gib", memory_gib)
        if num_virtual_cpus is not None:
            pulumi.set(__self__, "num_virtual_cpus", num_virtual_cpus)
        if private_network_visibility is not None:
            pulumi.set(__self__, "private_network_visibility", private_network_visibility)
        if storage_gib is not None:
            pulumi.set(__self__, "storage_gib", storage_gib)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[str]:
        """
        Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4.
        """
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> Optional[float]:
        """
        Memory per node in GiB.
        """
        return pulumi.get(self, "memory_gib")

    @property
    @pulumi.getter(name="numVirtualCpus")
    def num_virtual_cpus(self) -> Optional[int]:
        """
        Number of virtual CPUs per node in the cluster.
        """
        return pulumi.get(self, "num_virtual_cpus")

    @property
    @pulumi.getter(name="privateNetworkVisibility")
    def private_network_visibility(self) -> Optional[bool]:
        """
        Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features.
        """
        return pulumi.get(self, "private_network_visibility")

    @property
    @pulumi.getter(name="storageGib")
    def storage_gib(self) -> Optional[int]:
        """
        Storage amount per node in GiB.
        """
        return pulumi.get(self, "storage_gib")


@pulumi.output_type
class ClusterRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalDns":
            suggest = "internal_dns"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "sqlDns":
            suggest = "sql_dns"
        elif key == "uiDns":
            suggest = "ui_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 internal_dns: Optional[str] = None,
                 node_count: Optional[int] = None,
                 primary: Optional[bool] = None,
                 sql_dns: Optional[str] = None,
                 ui_dns: Optional[str] = None):
        """
        :param str name: Name of the region. Should match the region code used by the cluster's cloud provider.
        :param str internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param int node_count: Number of nodes in the region. Will always be 0 for serverless clusters.
        :param bool primary: Set to true to mark this region as the primary for a Serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        :param str sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param str ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "name", name)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if sql_dns is not None:
            pulumi.set(__self__, "sql_dns", sql_dns)
        if ui_dns is not None:
            pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[str]:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Set to true to mark this region as the primary for a Serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> Optional[str]:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> Optional[str]:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")


@pulumi.output_type
class ClusterServerless(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingId":
            suggest = "routing_id"
        elif key == "spendLimit":
            suggest = "spend_limit"
        elif key == "usageLimits":
            suggest = "usage_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServerless. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServerless.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServerless.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 routing_id: Optional[str] = None,
                 spend_limit: Optional[int] = None,
                 usage_limits: Optional['outputs.ClusterServerlessUsageLimits'] = None):
        """
        :param str routing_id: Cluster identifier in a connection string.
        :param int spend_limit: Spend limit in US cents.
        """
        if routing_id is not None:
            pulumi.set(__self__, "routing_id", routing_id)
        if spend_limit is not None:
            pulumi.set(__self__, "spend_limit", spend_limit)
        if usage_limits is not None:
            pulumi.set(__self__, "usage_limits", usage_limits)

    @property
    @pulumi.getter(name="routingId")
    def routing_id(self) -> Optional[str]:
        """
        Cluster identifier in a connection string.
        """
        return pulumi.get(self, "routing_id")

    @property
    @pulumi.getter(name="spendLimit")
    def spend_limit(self) -> Optional[int]:
        """
        Spend limit in US cents.
        """
        return pulumi.get(self, "spend_limit")

    @property
    @pulumi.getter(name="usageLimits")
    def usage_limits(self) -> Optional['outputs.ClusterServerlessUsageLimits']:
        return pulumi.get(self, "usage_limits")


@pulumi.output_type
class ClusterServerlessUsageLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestUnitLimit":
            suggest = "request_unit_limit"
        elif key == "storageMibLimit":
            suggest = "storage_mib_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServerlessUsageLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServerlessUsageLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServerlessUsageLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_unit_limit: int,
                 storage_mib_limit: int):
        """
        :param int request_unit_limit: Maximum number of Request Units that the cluster can consume during the month.
        :param int storage_mib_limit: Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        pulumi.set(__self__, "request_unit_limit", request_unit_limit)
        pulumi.set(__self__, "storage_mib_limit", storage_mib_limit)

    @property
    @pulumi.getter(name="requestUnitLimit")
    def request_unit_limit(self) -> int:
        """
        Maximum number of Request Units that the cluster can consume during the month.
        """
        return pulumi.get(self, "request_unit_limit")

    @property
    @pulumi.getter(name="storageMibLimit")
    def storage_mib_limit(self) -> int:
        """
        Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        return pulumi.get(self, "storage_mib_limit")


@pulumi.output_type
class CmekAdditionalRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalDns":
            suggest = "internal_dns"
        elif key == "nodeCount":
            suggest = "node_count"
        elif key == "sqlDns":
            suggest = "sql_dns"
        elif key == "uiDns":
            suggest = "ui_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmekAdditionalRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmekAdditionalRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmekAdditionalRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 internal_dns: Optional[str] = None,
                 node_count: Optional[int] = None,
                 primary: Optional[bool] = None,
                 sql_dns: Optional[str] = None,
                 ui_dns: Optional[str] = None):
        """
        :param str name: Name of the region. Should match the region code used by the cluster's cloud provider.
        :param str internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param int node_count: Number of nodes in the region. Will always be 0 for serverless clusters.
        :param bool primary: Set to true to mark this region as the primary for a Serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        :param str sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param str ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "name", name)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if sql_dns is not None:
            pulumi.set(__self__, "sql_dns", sql_dns)
        if ui_dns is not None:
            pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[str]:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Set to true to mark this region as the primary for a Serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> Optional[str]:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> Optional[str]:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")


@pulumi.output_type
class CmekRegion(dict):
    def __init__(__self__, *,
                 key: 'outputs.CmekRegionKey',
                 region: str,
                 status: Optional[str] = None):
        """
        :param str region: Cloud provider region code.
        :param str status: Describes the status of the current encryption key within the region.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def key(self) -> 'outputs.CmekRegionKey':
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Cloud provider region code.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Describes the status of the current encryption key within the region.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CmekRegionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authPrincipal":
            suggest = "auth_principal"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "userMessage":
            suggest = "user_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmekRegionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmekRegionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmekRegionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_principal: str,
                 type: str,
                 uri: str,
                 created_at: Optional[str] = None,
                 status: Optional[str] = None,
                 updated_at: Optional[str] = None,
                 user_message: Optional[str] = None):
        """
        :param str auth_principal: Principal to authenticate as in order to access the key.
        :param str type: Type of encryption key. Current allowed values are:
                 * AWS_KMS
                 * GCP_CLOUD_KMS
                 * NULL_KMS
        :param str uri: Provider-specific URI pointing to the encryption key.
        :param str created_at: Indicates when the key was created.
        :param str status: Current status of this key.
        :param str updated_at: Indicates when the key was last updated.
        :param str user_message: Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
        pulumi.set(__self__, "auth_principal", auth_principal)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_message is not None:
            pulumi.set(__self__, "user_message", user_message)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> str:
        """
        Principal to authenticate as in order to access the key.
        """
        return pulumi.get(self, "auth_principal")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of encryption key. Current allowed values are:
          * AWS_KMS
          * GCP_CLOUD_KMS
          * NULL_KMS
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Provider-specific URI pointing to the encryption key.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        Indicates when the key was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Current status of this key.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        Indicates when the key was last updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter(name="userMessage")
    def user_message(self) -> Optional[str]:
        """
        Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
        return pulumi.get(self, "user_message")


@pulumi.output_type
class LogExportConfigGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logName":
            suggest = "log_name"
        elif key == "minLevel":
            suggest = "min_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogExportConfigGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogExportConfigGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogExportConfigGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channels: Sequence[str],
                 log_name: str,
                 min_level: Optional[str] = None,
                 redact: Optional[bool] = None):
        """
        :param Sequence[str] channels: A list of CockroachDB log channels to include in this group.
        :param str log_name: The name of the group, reflected in the log sink.
        :param str min_level: The minimum log level to filter to this log group.
        :param bool redact: Governs whether this log group should aggregate redacted logs if unset.
        """
        pulumi.set(__self__, "channels", channels)
        pulumi.set(__self__, "log_name", log_name)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)

    @property
    @pulumi.getter
    def channels(self) -> Sequence[str]:
        """
        A list of CockroachDB log channels to include in this group.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> str:
        """
        The name of the group, reflected in the log sink.
        """
        return pulumi.get(self, "log_name")

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[str]:
        """
        The minimum log level to filter to this log group.
        """
        return pulumi.get(self, "min_level")

    @property
    @pulumi.getter
    def redact(self) -> Optional[bool]:
        """
        Governs whether this log group should aggregate redacted logs if unset.
        """
        return pulumi.get(self, "redact")


@pulumi.output_type
class PrivateEndpointServicesService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointServicesService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointServicesService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointServicesService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws: Optional['outputs.PrivateEndpointServicesServiceAws'] = None,
                 cloud_provider: Optional[str] = None,
                 region_name: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str cloud_provider: Cloud provider associated with this service.
        :param str region_name: Cloud provider region code associated with this service.
        :param str status: Operation status of the service.
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def aws(self) -> Optional['outputs.PrivateEndpointServicesServiceAws']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Cloud provider associated with this service.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        Cloud provider region code associated with this service.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Operation status of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PrivateEndpointServicesServiceAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZoneIds":
            suggest = "availability_zone_ids"
        elif key == "serviceId":
            suggest = "service_id"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointServicesServiceAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointServicesServiceAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointServicesServiceAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone_ids: Optional[Sequence[str]] = None,
                 service_id: Optional[str] = None,
                 service_name: Optional[str] = None):
        """
        :param Sequence[str] availability_zone_ids: AZ IDs users should create their VPCs in to minimize their cost.
        :param str service_id: Server side ID of the PrivateLink connection.
        :param str service_name: AWS service name used to create endpoints.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[Sequence[str]]:
        """
        AZ IDs users should create their VPCs in to minimize their cost.
        """
        return pulumi.get(self, "availability_zone_ids")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[str]:
        """
        Server side ID of the PrivateLink connection.
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        AWS service name used to create endpoints.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class UserRoleGrantsRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserRoleGrantsRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserRoleGrantsRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserRoleGrantsRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: str,
                 role_name: str,
                 resource_id: Optional[str] = None):
        """
        :param str resource_type: Type of resource. Allowed values are: 
                 * ORGANIZATION
                 * CLUSTER
                 * FOLDER
        :param str role_name: Name of the role to grant. Allowed values are:
                 * DEVELOPER
                 * ADMIN
                 * BILLING_COORDINATOR
                 * ORG_ADMIN
                 * ORG_MEMBER
                 * CLUSTER_ADMIN
                 * CLUSTER_OPERATOR_WRITER
                 * CLUSTER_DEVELOPER
                 * CLUSTER_CREATOR
                 * FOLDER_ADMIN
                 * FOLDER_MOVER
        :param str resource_id: ID of the resource. Omit if resource_type is 'ORGANIZATION'.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "role_name", role_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of resource. Allowed values are: 
          * ORGANIZATION
          * CLUSTER
          * FOLDER
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the role to grant. Allowed values are:
          * DEVELOPER
          * ADMIN
          * BILLING_COORDINATOR
          * ORG_ADMIN
          * ORG_MEMBER
          * CLUSTER_ADMIN
          * CLUSTER_OPERATOR_WRITER
          * CLUSTER_DEVELOPER
          * CLUSTER_CREATOR
          * FOLDER_ADMIN
          * FOLDER_MOVER
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ID of the resource. Omit if resource_type is 'ORGANIZATION'.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class GetCockroachClusterDedicatedResult(dict):
    def __init__(__self__, *,
                 disk_iops: int,
                 machine_type: str,
                 memory_gib: float,
                 num_virtual_cpus: int,
                 private_network_visibility: bool,
                 storage_gib: int):
        """
        :param int disk_iops: Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        :param str machine_type: Machine type identifier within the given cloud provider, ex. m6.xlarge, n2-standard-4.
        :param float memory_gib: Memory per node in GiB.
        :param int num_virtual_cpus: Number of virtual CPUs per node in the cluster.
        :param bool private_network_visibility: Indicates whether private IP addresses are assigned to nodes. Required for CMEK and other advanced networking features.
        :param int storage_gib: Storage amount per node in GiB.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "memory_gib", memory_gib)
        pulumi.set(__self__, "num_virtual_cpus", num_virtual_cpus)
        pulumi.set(__self__, "private_network_visibility", private_network_visibility)
        pulumi.set(__self__, "storage_gib", storage_gib)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> int:
        """
        Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        """
        Machine type identifier within the given cloud provider, ex. m6.xlarge, n2-standard-4.
        """
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> float:
        """
        Memory per node in GiB.
        """
        return pulumi.get(self, "memory_gib")

    @property
    @pulumi.getter(name="numVirtualCpus")
    def num_virtual_cpus(self) -> int:
        """
        Number of virtual CPUs per node in the cluster.
        """
        return pulumi.get(self, "num_virtual_cpus")

    @property
    @pulumi.getter(name="privateNetworkVisibility")
    def private_network_visibility(self) -> bool:
        """
        Indicates whether private IP addresses are assigned to nodes. Required for CMEK and other advanced networking features.
        """
        return pulumi.get(self, "private_network_visibility")

    @property
    @pulumi.getter(name="storageGib")
    def storage_gib(self) -> int:
        """
        Storage amount per node in GiB.
        """
        return pulumi.get(self, "storage_gib")


@pulumi.output_type
class GetCockroachClusterRegionResult(dict):
    def __init__(__self__, *,
                 internal_dns: str,
                 name: str,
                 node_count: int,
                 primary: bool,
                 sql_dns: str,
                 ui_dns: str):
        """
        :param str internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param str name: Region code used by the cluster's cloud provider.
        :param int node_count: Number of nodes in the region. Will always be 0 for serverless clusters.
        :param bool primary: Denotes whether this is the primary region in a serverless cluster. Dedicated clusters don't have a primary region.
        :param str sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param str ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "internal_dns", internal_dns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "sql_dns", sql_dns)
        pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> str:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        Denotes whether this is the primary region in a serverless cluster. Dedicated clusters don't have a primary region.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> str:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> str:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")


@pulumi.output_type
class GetCockroachClusterServerlessResult(dict):
    def __init__(__self__, *,
                 routing_id: str,
                 spend_limit: int,
                 usage_limits: 'outputs.GetCockroachClusterServerlessUsageLimitsResult'):
        """
        :param str routing_id: Cluster identifier in a connection string.
        :param int spend_limit: Spend limit in US cents.
        """
        pulumi.set(__self__, "routing_id", routing_id)
        pulumi.set(__self__, "spend_limit", spend_limit)
        pulumi.set(__self__, "usage_limits", usage_limits)

    @property
    @pulumi.getter(name="routingId")
    def routing_id(self) -> str:
        """
        Cluster identifier in a connection string.
        """
        return pulumi.get(self, "routing_id")

    @property
    @pulumi.getter(name="spendLimit")
    def spend_limit(self) -> int:
        """
        Spend limit in US cents.
        """
        return pulumi.get(self, "spend_limit")

    @property
    @pulumi.getter(name="usageLimits")
    def usage_limits(self) -> 'outputs.GetCockroachClusterServerlessUsageLimitsResult':
        return pulumi.get(self, "usage_limits")


@pulumi.output_type
class GetCockroachClusterServerlessUsageLimitsResult(dict):
    def __init__(__self__, *,
                 request_unit_limit: int,
                 storage_mib_limit: int):
        """
        :param int request_unit_limit: Maximum number of Request Units that the cluster can consume during the month.
        :param int storage_mib_limit: Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        pulumi.set(__self__, "request_unit_limit", request_unit_limit)
        pulumi.set(__self__, "storage_mib_limit", storage_mib_limit)

    @property
    @pulumi.getter(name="requestUnitLimit")
    def request_unit_limit(self) -> int:
        """
        Maximum number of Request Units that the cluster can consume during the month.
        """
        return pulumi.get(self, "request_unit_limit")

    @property
    @pulumi.getter(name="storageMibLimit")
    def storage_mib_limit(self) -> int:
        """
        Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        return pulumi.get(self, "storage_mib_limit")


@pulumi.output_type
class GetConnectionStringConnectionParamsResult(dict):
    def __init__(__self__, *,
                 database: str,
                 host: str,
                 password: str,
                 port: str,
                 username: str):
        """
        :param str database: Database value to use in a connection URL.
        :param str host: Host value to use in a connection URL.
        :param str password: Password value to use in a connection URL.
        :param str port: Port value to use in a connection URL.
        :param str username: Username value to use in a connection URL.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Database value to use in a connection URL.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host value to use in a connection URL.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password value to use in a connection URL.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Port value to use in a connection URL.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username value to use in a connection URL.
        """
        return pulumi.get(self, "username")


