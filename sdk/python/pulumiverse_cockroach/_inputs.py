# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ClusterBackupConfigArgs',
    'ClusterBackupConfigArgsDict',
    'ClusterDedicatedArgs',
    'ClusterDedicatedArgsDict',
    'ClusterRegionArgs',
    'ClusterRegionArgsDict',
    'ClusterServerlessArgs',
    'ClusterServerlessArgsDict',
    'ClusterServerlessUsageLimitsArgs',
    'ClusterServerlessUsageLimitsArgsDict',
    'CmekAdditionalRegionArgs',
    'CmekAdditionalRegionArgsDict',
    'CmekRegionArgs',
    'CmekRegionArgsDict',
    'CmekRegionKeyArgs',
    'CmekRegionKeyArgsDict',
    'JwtIssuerIdentityMapArgs',
    'JwtIssuerIdentityMapArgsDict',
    'LogExportConfigGroupArgs',
    'LogExportConfigGroupArgsDict',
    'PrivateEndpointServicesServiceArgs',
    'PrivateEndpointServicesServiceArgsDict',
    'PrivateEndpointServicesServiceAwsArgs',
    'PrivateEndpointServicesServiceAwsArgsDict',
    'PrivateEndpointServicesServicesMapArgs',
    'PrivateEndpointServicesServicesMapArgsDict',
    'PrivateEndpointServicesServicesMapAwsArgs',
    'PrivateEndpointServicesServicesMapAwsArgsDict',
    'UserRoleGrantRoleArgs',
    'UserRoleGrantRoleArgsDict',
    'UserRoleGrantsRoleArgs',
    'UserRoleGrantsRoleArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterBackupConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether backups are enabled. If set to false, no backups will be created.
        """
        frequency_minutes: NotRequired[pulumi.Input[int]]
        """
        The frequency of backups in minutes.  Valid values are [5, 10, 15, 30, 60, 240, 1440]
        """
        retention_days: NotRequired[pulumi.Input[int]]
        """
        The number of days to retain backups for.  Valid values are [2, 7, 30, 90, 365]. Can only be set once, further changes require opening a support ticket. See Updating backup retention for more information.
        """
elif False:
    ClusterBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBackupConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 frequency_minutes: Optional[pulumi.Input[int]] = None,
                 retention_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether backups are enabled. If set to false, no backups will be created.
        :param pulumi.Input[int] frequency_minutes: The frequency of backups in minutes.  Valid values are [5, 10, 15, 30, 60, 240, 1440]
        :param pulumi.Input[int] retention_days: The number of days to retain backups for.  Valid values are [2, 7, 30, 90, 365]. Can only be set once, further changes require opening a support ticket. See Updating backup retention for more information.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if frequency_minutes is not None:
            pulumi.set(__self__, "frequency_minutes", frequency_minutes)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether backups are enabled. If set to false, no backups will be created.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="frequencyMinutes")
    def frequency_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The frequency of backups in minutes.  Valid values are [5, 10, 15, 30, 60, 240, 1440]
        """
        return pulumi.get(self, "frequency_minutes")

    @frequency_minutes.setter
    def frequency_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frequency_minutes", value)

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days to retain backups for.  Valid values are [2, 7, 30, 90, 365]. Can only be set once, further changes require opening a support ticket. See Updating backup retention for more information.
        """
        return pulumi.get(self, "retention_days")

    @retention_days.setter
    def retention_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_days", value)


if not MYPY:
    class ClusterDedicatedArgsDict(TypedDict):
        cidr_range: NotRequired[pulumi.Input[str]]
        """
        The IPv4 range in CIDR format that will be used by the cluster. This is supported only on GCP, and must have a subnet mask no larger than /19. Defaults to "172.28.0.0/14". This cannot be changed after cluster creation.
        """
        disk_iops: NotRequired[pulumi.Input[int]]
        """
        Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        """
        machine_type: NotRequired[pulumi.Input[str]]
        """
        Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4.
        """
        memory_gib: NotRequired[pulumi.Input[float]]
        """
        Memory per node in GiB.
        """
        num_virtual_cpus: NotRequired[pulumi.Input[int]]
        """
        Number of virtual CPUs per node in the cluster.
        """
        private_network_visibility: NotRequired[pulumi.Input[bool]]
        """
        Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features. Clusters created with this flag will have advanced security features enabled.  This cannot be changed after cluster creation and incurs additional charges.  See [Create an Advanced Cluster](https://www.cockroachlabs.com/docs/cockroachcloud/create-an-advanced-cluster.html#step-6-configure-advanced-security-features) and [Pricing](https://www.cockroachlabs.com/pricing/) for more information.
        """
        storage_gib: NotRequired[pulumi.Input[int]]
        """
        Storage amount per node in GiB.
        """
elif False:
    ClusterDedicatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterDedicatedArgs:
    def __init__(__self__, *,
                 cidr_range: Optional[pulumi.Input[str]] = None,
                 disk_iops: Optional[pulumi.Input[int]] = None,
                 machine_type: Optional[pulumi.Input[str]] = None,
                 memory_gib: Optional[pulumi.Input[float]] = None,
                 num_virtual_cpus: Optional[pulumi.Input[int]] = None,
                 private_network_visibility: Optional[pulumi.Input[bool]] = None,
                 storage_gib: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] cidr_range: The IPv4 range in CIDR format that will be used by the cluster. This is supported only on GCP, and must have a subnet mask no larger than /19. Defaults to "172.28.0.0/14". This cannot be changed after cluster creation.
        :param pulumi.Input[int] disk_iops: Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        :param pulumi.Input[str] machine_type: Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4.
        :param pulumi.Input[float] memory_gib: Memory per node in GiB.
        :param pulumi.Input[int] num_virtual_cpus: Number of virtual CPUs per node in the cluster.
        :param pulumi.Input[bool] private_network_visibility: Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features. Clusters created with this flag will have advanced security features enabled.  This cannot be changed after cluster creation and incurs additional charges.  See [Create an Advanced Cluster](https://www.cockroachlabs.com/docs/cockroachcloud/create-an-advanced-cluster.html#step-6-configure-advanced-security-features) and [Pricing](https://www.cockroachlabs.com/pricing/) for more information.
        :param pulumi.Input[int] storage_gib: Storage amount per node in GiB.
        """
        if cidr_range is not None:
            pulumi.set(__self__, "cidr_range", cidr_range)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if memory_gib is not None:
            pulumi.set(__self__, "memory_gib", memory_gib)
        if num_virtual_cpus is not None:
            pulumi.set(__self__, "num_virtual_cpus", num_virtual_cpus)
        if private_network_visibility is not None:
            pulumi.set(__self__, "private_network_visibility", private_network_visibility)
        if storage_gib is not None:
            pulumi.set(__self__, "storage_gib", storage_gib)

    @property
    @pulumi.getter(name="cidrRange")
    def cidr_range(self) -> Optional[pulumi.Input[str]]:
        """
        The IPv4 range in CIDR format that will be used by the cluster. This is supported only on GCP, and must have a subnet mask no larger than /19. Defaults to "172.28.0.0/14". This cannot be changed after cluster creation.
        """
        return pulumi.get(self, "cidr_range")

    @cidr_range.setter
    def cidr_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_range", value)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        """
        return pulumi.get(self, "disk_iops")

    @disk_iops.setter
    def disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_iops", value)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[str]]:
        """
        Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4.
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_type", value)

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Memory per node in GiB.
        """
        return pulumi.get(self, "memory_gib")

    @memory_gib.setter
    def memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_gib", value)

    @property
    @pulumi.getter(name="numVirtualCpus")
    def num_virtual_cpus(self) -> Optional[pulumi.Input[int]]:
        """
        Number of virtual CPUs per node in the cluster.
        """
        return pulumi.get(self, "num_virtual_cpus")

    @num_virtual_cpus.setter
    def num_virtual_cpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_virtual_cpus", value)

    @property
    @pulumi.getter(name="privateNetworkVisibility")
    def private_network_visibility(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features. Clusters created with this flag will have advanced security features enabled.  This cannot be changed after cluster creation and incurs additional charges.  See [Create an Advanced Cluster](https://www.cockroachlabs.com/docs/cockroachcloud/create-an-advanced-cluster.html#step-6-configure-advanced-security-features) and [Pricing](https://www.cockroachlabs.com/pricing/) for more information.
        """
        return pulumi.get(self, "private_network_visibility")

    @private_network_visibility.setter
    def private_network_visibility(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_network_visibility", value)

    @property
    @pulumi.getter(name="storageGib")
    def storage_gib(self) -> Optional[pulumi.Input[int]]:
        """
        Storage amount per node in GiB.
        """
        return pulumi.get(self, "storage_gib")

    @storage_gib.setter
    def storage_gib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage_gib", value)


if not MYPY:
    class ClusterRegionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        internal_dns: NotRequired[pulumi.Input[str]]
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        node_count: NotRequired[pulumi.Input[int]]
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        primary: NotRequired[pulumi.Input[bool]]
        """
        Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        sql_dns: NotRequired[pulumi.Input[str]]
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        ui_dns: NotRequired[pulumi.Input[str]]
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
elif False:
    ClusterRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRegionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 internal_dns: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 sql_dns: Optional[pulumi.Input[str]] = None,
                 ui_dns: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the region. Should match the region code used by the cluster's cloud provider.
        :param pulumi.Input[str] internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param pulumi.Input[int] node_count: Number of nodes in the region. Will always be 0 for serverless clusters.
        :param pulumi.Input[bool] primary: Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        :param pulumi.Input[str] sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param pulumi.Input[str] ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "name", name)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if sql_dns is not None:
            pulumi.set(__self__, "sql_dns", sql_dns)
        if ui_dns is not None:
            pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[pulumi.Input[str]]:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @internal_dns.setter
    def internal_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_dns", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @sql_dns.setter
    def sql_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_dns", value)

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")

    @ui_dns.setter
    def ui_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ui_dns", value)


if not MYPY:
    class ClusterServerlessArgsDict(TypedDict):
        routing_id: NotRequired[pulumi.Input[str]]
        """
        Cluster identifier in a connection string.
        """
        spend_limit: NotRequired[pulumi.Input[int]]
        """
        Spend limit in US cents.
        """
        upgrade_type: NotRequired[pulumi.Input[str]]
        """
        Dictates the behavior of CockroachDB major version upgrades. Manual upgrades are not supported on CockroachDB Basic. Manual or automatic upgrades are supported on CockroachDB Standard. If you omit the field, it defaults to `AUTOMATIC`. Allowed values are:
          * MANUAL
          * AUTOMATIC
        """
        usage_limits: NotRequired[pulumi.Input['ClusterServerlessUsageLimitsArgsDict']]
elif False:
    ClusterServerlessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterServerlessArgs:
    def __init__(__self__, *,
                 routing_id: Optional[pulumi.Input[str]] = None,
                 spend_limit: Optional[pulumi.Input[int]] = None,
                 upgrade_type: Optional[pulumi.Input[str]] = None,
                 usage_limits: Optional[pulumi.Input['ClusterServerlessUsageLimitsArgs']] = None):
        """
        :param pulumi.Input[str] routing_id: Cluster identifier in a connection string.
        :param pulumi.Input[int] spend_limit: Spend limit in US cents.
        :param pulumi.Input[str] upgrade_type: Dictates the behavior of CockroachDB major version upgrades. Manual upgrades are not supported on CockroachDB Basic. Manual or automatic upgrades are supported on CockroachDB Standard. If you omit the field, it defaults to `AUTOMATIC`. Allowed values are:
                 * MANUAL
                 * AUTOMATIC
        """
        if routing_id is not None:
            pulumi.set(__self__, "routing_id", routing_id)
        if spend_limit is not None:
            warnings.warn("""The `spend_limit` attribute is deprecated and will be removed in a future release of the provider. Configure 'usage_limits' instead.""", DeprecationWarning)
            pulumi.log.warn("""spend_limit is deprecated: The `spend_limit` attribute is deprecated and will be removed in a future release of the provider. Configure 'usage_limits' instead.""")
        if spend_limit is not None:
            pulumi.set(__self__, "spend_limit", spend_limit)
        if upgrade_type is not None:
            pulumi.set(__self__, "upgrade_type", upgrade_type)
        if usage_limits is not None:
            pulumi.set(__self__, "usage_limits", usage_limits)

    @property
    @pulumi.getter(name="routingId")
    def routing_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster identifier in a connection string.
        """
        return pulumi.get(self, "routing_id")

    @routing_id.setter
    def routing_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_id", value)

    @property
    @pulumi.getter(name="spendLimit")
    @_utilities.deprecated("""The `spend_limit` attribute is deprecated and will be removed in a future release of the provider. Configure 'usage_limits' instead.""")
    def spend_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Spend limit in US cents.
        """
        return pulumi.get(self, "spend_limit")

    @spend_limit.setter
    def spend_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spend_limit", value)

    @property
    @pulumi.getter(name="upgradeType")
    def upgrade_type(self) -> Optional[pulumi.Input[str]]:
        """
        Dictates the behavior of CockroachDB major version upgrades. Manual upgrades are not supported on CockroachDB Basic. Manual or automatic upgrades are supported on CockroachDB Standard. If you omit the field, it defaults to `AUTOMATIC`. Allowed values are:
          * MANUAL
          * AUTOMATIC
        """
        return pulumi.get(self, "upgrade_type")

    @upgrade_type.setter
    def upgrade_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "upgrade_type", value)

    @property
    @pulumi.getter(name="usageLimits")
    def usage_limits(self) -> Optional[pulumi.Input['ClusterServerlessUsageLimitsArgs']]:
        return pulumi.get(self, "usage_limits")

    @usage_limits.setter
    def usage_limits(self, value: Optional[pulumi.Input['ClusterServerlessUsageLimitsArgs']]):
        pulumi.set(self, "usage_limits", value)


if not MYPY:
    class ClusterServerlessUsageLimitsArgsDict(TypedDict):
        provisioned_virtual_cpus: NotRequired[pulumi.Input[int]]
        """
        Maximum number of vCPUs that the cluster can use.
        """
        request_unit_limit: NotRequired[pulumi.Input[int]]
        """
        Maximum number of Request Units that the cluster can consume during the month.
        """
        storage_mib_limit: NotRequired[pulumi.Input[int]]
        """
        Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
elif False:
    ClusterServerlessUsageLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterServerlessUsageLimitsArgs:
    def __init__(__self__, *,
                 provisioned_virtual_cpus: Optional[pulumi.Input[int]] = None,
                 request_unit_limit: Optional[pulumi.Input[int]] = None,
                 storage_mib_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] provisioned_virtual_cpus: Maximum number of vCPUs that the cluster can use.
        :param pulumi.Input[int] request_unit_limit: Maximum number of Request Units that the cluster can consume during the month.
        :param pulumi.Input[int] storage_mib_limit: Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        if provisioned_virtual_cpus is not None:
            pulumi.set(__self__, "provisioned_virtual_cpus", provisioned_virtual_cpus)
        if request_unit_limit is not None:
            pulumi.set(__self__, "request_unit_limit", request_unit_limit)
        if storage_mib_limit is not None:
            pulumi.set(__self__, "storage_mib_limit", storage_mib_limit)

    @property
    @pulumi.getter(name="provisionedVirtualCpus")
    def provisioned_virtual_cpus(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of vCPUs that the cluster can use.
        """
        return pulumi.get(self, "provisioned_virtual_cpus")

    @provisioned_virtual_cpus.setter
    def provisioned_virtual_cpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "provisioned_virtual_cpus", value)

    @property
    @pulumi.getter(name="requestUnitLimit")
    def request_unit_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of Request Units that the cluster can consume during the month.
        """
        return pulumi.get(self, "request_unit_limit")

    @request_unit_limit.setter
    def request_unit_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_unit_limit", value)

    @property
    @pulumi.getter(name="storageMibLimit")
    def storage_mib_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        return pulumi.get(self, "storage_mib_limit")

    @storage_mib_limit.setter
    def storage_mib_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage_mib_limit", value)


if not MYPY:
    class CmekAdditionalRegionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        internal_dns: NotRequired[pulumi.Input[str]]
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        node_count: NotRequired[pulumi.Input[int]]
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        primary: NotRequired[pulumi.Input[bool]]
        """
        Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        sql_dns: NotRequired[pulumi.Input[str]]
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        ui_dns: NotRequired[pulumi.Input[str]]
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
elif False:
    CmekAdditionalRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmekAdditionalRegionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 internal_dns: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 sql_dns: Optional[pulumi.Input[str]] = None,
                 ui_dns: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the region. Should match the region code used by the cluster's cloud provider.
        :param pulumi.Input[str] internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param pulumi.Input[int] node_count: Number of nodes in the region. Will always be 0 for serverless clusters.
        :param pulumi.Input[bool] primary: Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        :param pulumi.Input[str] sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param pulumi.Input[str] ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "name", name)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if sql_dns is not None:
            pulumi.set(__self__, "sql_dns", sql_dns)
        if ui_dns is not None:
            pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[pulumi.Input[str]]:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @internal_dns.setter
    def internal_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_dns", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to mark this region as the primary for a serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @sql_dns.setter
    def sql_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_dns", value)

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")

    @ui_dns.setter
    def ui_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ui_dns", value)


if not MYPY:
    class CmekRegionArgsDict(TypedDict):
        key: pulumi.Input['CmekRegionKeyArgsDict']
        region: pulumi.Input[str]
        """
        Cloud provider region code.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Describes the status of the current encryption key within the region.
        """
elif False:
    CmekRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmekRegionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input['CmekRegionKeyArgs'],
                 region: pulumi.Input[str],
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: Cloud provider region code.
        :param pulumi.Input[str] status: Describes the status of the current encryption key within the region.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input['CmekRegionKeyArgs']:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input['CmekRegionKeyArgs']):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Cloud provider region code.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the status of the current encryption key within the region.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class CmekRegionKeyArgsDict(TypedDict):
        auth_principal: pulumi.Input[str]
        """
        Principal to authenticate as in order to access the key.
        """
        type: pulumi.Input[str]
        """
        Type of encryption key. Current allowed values are:
          * AWS_KMS
          * GCP_CLOUD_KMS
          * NULL_KMS
        """
        uri: pulumi.Input[str]
        """
        Provider-specific URI pointing to the encryption key.
        """
        created_at: NotRequired[pulumi.Input[str]]
        """
        Indicates when the key was created.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Current status of this key.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        Indicates when the key was last updated.
        """
        user_message: NotRequired[pulumi.Input[str]]
        """
        Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
elif False:
    CmekRegionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmekRegionKeyArgs:
    def __init__(__self__, *,
                 auth_principal: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uri: pulumi.Input[str],
                 created_at: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None,
                 user_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_principal: Principal to authenticate as in order to access the key.
        :param pulumi.Input[str] type: Type of encryption key. Current allowed values are:
                 * AWS_KMS
                 * GCP_CLOUD_KMS
                 * NULL_KMS
        :param pulumi.Input[str] uri: Provider-specific URI pointing to the encryption key.
        :param pulumi.Input[str] created_at: Indicates when the key was created.
        :param pulumi.Input[str] status: Current status of this key.
        :param pulumi.Input[str] updated_at: Indicates when the key was last updated.
        :param pulumi.Input[str] user_message: Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
        pulumi.set(__self__, "auth_principal", auth_principal)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_message is not None:
            pulumi.set(__self__, "user_message", user_message)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> pulumi.Input[str]:
        """
        Principal to authenticate as in order to access the key.
        """
        return pulumi.get(self, "auth_principal")

    @auth_principal.setter
    def auth_principal(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_principal", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of encryption key. Current allowed values are:
          * AWS_KMS
          * GCP_CLOUD_KMS
          * NULL_KMS
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Provider-specific URI pointing to the encryption key.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates when the key was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Current status of this key.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates when the key was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="userMessage")
    def user_message(self) -> Optional[pulumi.Input[str]]:
        """
        Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
        return pulumi.get(self, "user_message")

    @user_message.setter
    def user_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_message", value)


if not MYPY:
    class JwtIssuerIdentityMapArgsDict(TypedDict):
        cc_identity: pulumi.Input[str]
        """
        Specifies how to map the fetched token identity to an identity in CockroachDB Cloud. In case of a regular expression for token_identity, this must contain a \\1 placeholder for the matched content. Note that you will need to escape the backslash in the string as in the example usage (\\\\1).
        """
        token_identity: pulumi.Input[str]
        """
        Specifies how to fetch external identity from the token claim. A regular expression must start with a forward slash. The regular expression must be in RE2 compatible syntax. For further details, please see https://github.com/google/re2/wiki/Syntax.
        """
elif False:
    JwtIssuerIdentityMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JwtIssuerIdentityMapArgs:
    def __init__(__self__, *,
                 cc_identity: pulumi.Input[str],
                 token_identity: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cc_identity: Specifies how to map the fetched token identity to an identity in CockroachDB Cloud. In case of a regular expression for token_identity, this must contain a \\1 placeholder for the matched content. Note that you will need to escape the backslash in the string as in the example usage (\\\\1).
        :param pulumi.Input[str] token_identity: Specifies how to fetch external identity from the token claim. A regular expression must start with a forward slash. The regular expression must be in RE2 compatible syntax. For further details, please see https://github.com/google/re2/wiki/Syntax.
        """
        pulumi.set(__self__, "cc_identity", cc_identity)
        pulumi.set(__self__, "token_identity", token_identity)

    @property
    @pulumi.getter(name="ccIdentity")
    def cc_identity(self) -> pulumi.Input[str]:
        """
        Specifies how to map the fetched token identity to an identity in CockroachDB Cloud. In case of a regular expression for token_identity, this must contain a \\1 placeholder for the matched content. Note that you will need to escape the backslash in the string as in the example usage (\\\\1).
        """
        return pulumi.get(self, "cc_identity")

    @cc_identity.setter
    def cc_identity(self, value: pulumi.Input[str]):
        pulumi.set(self, "cc_identity", value)

    @property
    @pulumi.getter(name="tokenIdentity")
    def token_identity(self) -> pulumi.Input[str]:
        """
        Specifies how to fetch external identity from the token claim. A regular expression must start with a forward slash. The regular expression must be in RE2 compatible syntax. For further details, please see https://github.com/google/re2/wiki/Syntax.
        """
        return pulumi.get(self, "token_identity")

    @token_identity.setter
    def token_identity(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_identity", value)


if not MYPY:
    class LogExportConfigGroupArgsDict(TypedDict):
        channels: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of CockroachDB log channels to include in this group.
        """
        log_name: pulumi.Input[str]
        """
        The name of the group, reflected in the log sink.
        """
        min_level: NotRequired[pulumi.Input[str]]
        """
        The minimum log level to filter to this log group.
        """
        redact: NotRequired[pulumi.Input[bool]]
        """
        Governs whether this log group should aggregate redacted logs if unset.
        """
elif False:
    LogExportConfigGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogExportConfigGroupArgs:
    def __init__(__self__, *,
                 channels: pulumi.Input[Sequence[pulumi.Input[str]]],
                 log_name: pulumi.Input[str],
                 min_level: Optional[pulumi.Input[str]] = None,
                 redact: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] channels: A list of CockroachDB log channels to include in this group.
        :param pulumi.Input[str] log_name: The name of the group, reflected in the log sink.
        :param pulumi.Input[str] min_level: The minimum log level to filter to this log group.
        :param pulumi.Input[bool] redact: Governs whether this log group should aggregate redacted logs if unset.
        """
        pulumi.set(__self__, "channels", channels)
        pulumi.set(__self__, "log_name", log_name)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)

    @property
    @pulumi.getter
    def channels(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of CockroachDB log channels to include in this group.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> pulumi.Input[str]:
        """
        The name of the group, reflected in the log sink.
        """
        return pulumi.get(self, "log_name")

    @log_name.setter
    def log_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_name", value)

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum log level to filter to this log group.
        """
        return pulumi.get(self, "min_level")

    @min_level.setter
    def min_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_level", value)

    @property
    @pulumi.getter
    def redact(self) -> Optional[pulumi.Input[bool]]:
        """
        Governs whether this log group should aggregate redacted logs if unset.
        """
        return pulumi.get(self, "redact")

    @redact.setter
    def redact(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redact", value)


if not MYPY:
    class PrivateEndpointServicesServiceArgsDict(TypedDict):
        availability_zone_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        """
        aws: NotRequired[pulumi.Input['PrivateEndpointServicesServiceAwsArgsDict']]
        cloud_provider: NotRequired[pulumi.Input[str]]
        """
        Cloud provider associated with this service.
        """
        endpoint_service_id: NotRequired[pulumi.Input[str]]
        """
        Server side ID of the private endpoint connection.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the endpoint service.
        """
        region_name: NotRequired[pulumi.Input[str]]
        """
        Cloud provider region code associated with this service.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Operation status of the service.
        """
elif False:
    PrivateEndpointServicesServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointServicesServiceArgs:
    def __init__(__self__, *,
                 availability_zone_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 aws: Optional[pulumi.Input['PrivateEndpointServicesServiceAwsArgs']] = None,
                 cloud_provider: Optional[pulumi.Input[str]] = None,
                 endpoint_service_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 region_name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zone_ids: Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        :param pulumi.Input[str] cloud_provider: Cloud provider associated with this service.
        :param pulumi.Input[str] endpoint_service_id: Server side ID of the private endpoint connection.
        :param pulumi.Input[str] name: Name of the endpoint service.
        :param pulumi.Input[str] region_name: Cloud provider region code associated with this service.
        :param pulumi.Input[str] status: Operation status of the service.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if aws is not None:
            warnings.warn("""nested aws fields have been moved one level up. These fields will be removed in a future version""", DeprecationWarning)
            pulumi.log.warn("""aws is deprecated: nested aws fields have been moved one level up. These fields will be removed in a future version""")
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if endpoint_service_id is not None:
            pulumi.set(__self__, "endpoint_service_id", endpoint_service_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        """
        return pulumi.get(self, "availability_zone_ids")

    @availability_zone_ids.setter
    def availability_zone_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zone_ids", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""nested aws fields have been moved one level up. These fields will be removed in a future version""")
    def aws(self) -> Optional[pulumi.Input['PrivateEndpointServicesServiceAwsArgs']]:
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['PrivateEndpointServicesServiceAwsArgs']]):
        pulumi.set(self, "aws", value)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud provider associated with this service.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter(name="endpointServiceId")
    def endpoint_service_id(self) -> Optional[pulumi.Input[str]]:
        """
        Server side ID of the private endpoint connection.
        """
        return pulumi.get(self, "endpoint_service_id")

    @endpoint_service_id.setter
    def endpoint_service_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_service_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the endpoint service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud provider region code associated with this service.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Operation status of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PrivateEndpointServicesServiceAwsArgsDict(TypedDict):
        availability_zone_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        AZ IDs users should create their VPCs in to minimize their cost.
        """
        service_id: NotRequired[pulumi.Input[str]]
        """
        Server side ID of the PrivateLink connection.
        """
        service_name: NotRequired[pulumi.Input[str]]
        """
        AWS service name used to create endpoints.
        """
elif False:
    PrivateEndpointServicesServiceAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointServicesServiceAwsArgs:
    def __init__(__self__, *,
                 availability_zone_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_id: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zone_ids: AZ IDs users should create their VPCs in to minimize their cost.
        :param pulumi.Input[str] service_id: Server side ID of the PrivateLink connection.
        :param pulumi.Input[str] service_name: AWS service name used to create endpoints.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AZ IDs users should create their VPCs in to minimize their cost.
        """
        return pulumi.get(self, "availability_zone_ids")

    @availability_zone_ids.setter
    def availability_zone_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zone_ids", value)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[str]]:
        """
        Server side ID of the PrivateLink connection.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_id", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        AWS service name used to create endpoints.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class PrivateEndpointServicesServicesMapArgsDict(TypedDict):
        availability_zone_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        """
        aws: NotRequired[pulumi.Input['PrivateEndpointServicesServicesMapAwsArgsDict']]
        cloud_provider: NotRequired[pulumi.Input[str]]
        """
        Cloud provider associated with this service.
        """
        endpoint_service_id: NotRequired[pulumi.Input[str]]
        """
        Server side ID of the private endpoint connection.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the endpoint service.
        """
        region_name: NotRequired[pulumi.Input[str]]
        """
        Cloud provider region code associated with this service.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Operation status of the service.
        """
elif False:
    PrivateEndpointServicesServicesMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointServicesServicesMapArgs:
    def __init__(__self__, *,
                 availability_zone_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 aws: Optional[pulumi.Input['PrivateEndpointServicesServicesMapAwsArgs']] = None,
                 cloud_provider: Optional[pulumi.Input[str]] = None,
                 endpoint_service_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 region_name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zone_ids: Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        :param pulumi.Input[str] cloud_provider: Cloud provider associated with this service.
        :param pulumi.Input[str] endpoint_service_id: Server side ID of the private endpoint connection.
        :param pulumi.Input[str] name: Name of the endpoint service.
        :param pulumi.Input[str] region_name: Cloud provider region code associated with this service.
        :param pulumi.Input[str] status: Operation status of the service.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if aws is not None:
            warnings.warn("""nested aws fields have been moved one level up. These fields will be removed in a future version""", DeprecationWarning)
            pulumi.log.warn("""aws is deprecated: nested aws fields have been moved one level up. These fields will be removed in a future version""")
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if endpoint_service_id is not None:
            pulumi.set(__self__, "endpoint_service_id", endpoint_service_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Availability Zone IDs of the private endpoint service. It is recommended, for cost optimization purposes, to create the private endpoint spanning these same availability zones. For more information, see data transfer cost information for your cloud provider.
        """
        return pulumi.get(self, "availability_zone_ids")

    @availability_zone_ids.setter
    def availability_zone_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zone_ids", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""nested aws fields have been moved one level up. These fields will be removed in a future version""")
    def aws(self) -> Optional[pulumi.Input['PrivateEndpointServicesServicesMapAwsArgs']]:
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['PrivateEndpointServicesServicesMapAwsArgs']]):
        pulumi.set(self, "aws", value)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud provider associated with this service.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter(name="endpointServiceId")
    def endpoint_service_id(self) -> Optional[pulumi.Input[str]]:
        """
        Server side ID of the private endpoint connection.
        """
        return pulumi.get(self, "endpoint_service_id")

    @endpoint_service_id.setter
    def endpoint_service_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_service_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the endpoint service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud provider region code associated with this service.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Operation status of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PrivateEndpointServicesServicesMapAwsArgsDict(TypedDict):
        availability_zone_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        AZ IDs users should create their VPCs in to minimize their cost.
        """
        service_id: NotRequired[pulumi.Input[str]]
        """
        Server side ID of the PrivateLink connection.
        """
        service_name: NotRequired[pulumi.Input[str]]
        """
        AWS service name used to create endpoints.
        """
elif False:
    PrivateEndpointServicesServicesMapAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointServicesServicesMapAwsArgs:
    def __init__(__self__, *,
                 availability_zone_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_id: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zone_ids: AZ IDs users should create their VPCs in to minimize their cost.
        :param pulumi.Input[str] service_id: Server side ID of the PrivateLink connection.
        :param pulumi.Input[str] service_name: AWS service name used to create endpoints.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AZ IDs users should create their VPCs in to minimize their cost.
        """
        return pulumi.get(self, "availability_zone_ids")

    @availability_zone_ids.setter
    def availability_zone_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zone_ids", value)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[str]]:
        """
        Server side ID of the PrivateLink connection.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_id", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        AWS service name used to create endpoints.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class UserRoleGrantRoleArgsDict(TypedDict):
        resource_type: pulumi.Input[str]
        """
        Type of resource. Allowed values are:
          * ORGANIZATION
          * CLUSTER
          * FOLDER
        """
        role_name: pulumi.Input[str]
        """
        Name of the role to grant. Allowed values are:
          * BILLING_COORDINATOR
          * ORG_ADMIN
          * ORG_MEMBER
          * CLUSTER_ADMIN
          * CLUSTER_OPERATOR_WRITER
          * CLUSTER_DEVELOPER
          * CLUSTER_CREATOR
          * FOLDER_ADMIN
          * FOLDER_MOVER
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
elif False:
    UserRoleGrantRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserRoleGrantRoleArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[str],
                 role_name: pulumi.Input[str],
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_type: Type of resource. Allowed values are:
                 * ORGANIZATION
                 * CLUSTER
                 * FOLDER
        :param pulumi.Input[str] role_name: Name of the role to grant. Allowed values are:
                 * BILLING_COORDINATOR
                 * ORG_ADMIN
                 * ORG_MEMBER
                 * CLUSTER_ADMIN
                 * CLUSTER_OPERATOR_WRITER
                 * CLUSTER_DEVELOPER
                 * CLUSTER_CREATOR
                 * FOLDER_ADMIN
                 * FOLDER_MOVER
        :param pulumi.Input[str] resource_id: ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "role_name", role_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        """
        Type of resource. Allowed values are:
          * ORGANIZATION
          * CLUSTER
          * FOLDER
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Name of the role to grant. Allowed values are:
          * BILLING_COORDINATOR
          * ORG_ADMIN
          * ORG_MEMBER
          * CLUSTER_ADMIN
          * CLUSTER_OPERATOR_WRITER
          * CLUSTER_DEVELOPER
          * CLUSTER_CREATOR
          * FOLDER_ADMIN
          * FOLDER_MOVER
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class UserRoleGrantsRoleArgsDict(TypedDict):
        resource_type: pulumi.Input[str]
        """
        Type of resource. Allowed values are: 
          * ORGANIZATION
          * CLUSTER
          * FOLDER
        """
        role_name: pulumi.Input[str]
        """
        Name of the role to grant. Allowed values are:
          * BILLING_COORDINATOR
          * ORG_ADMIN
          * ORG_MEMBER
          * CLUSTER_ADMIN
          * CLUSTER_OPERATOR_WRITER
          * CLUSTER_DEVELOPER
          * CLUSTER_CREATOR
          * FOLDER_ADMIN
          * FOLDER_MOVER
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
elif False:
    UserRoleGrantsRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserRoleGrantsRoleArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[str],
                 role_name: pulumi.Input[str],
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_type: Type of resource. Allowed values are: 
                 * ORGANIZATION
                 * CLUSTER
                 * FOLDER
        :param pulumi.Input[str] role_name: Name of the role to grant. Allowed values are:
                 * BILLING_COORDINATOR
                 * ORG_ADMIN
                 * ORG_MEMBER
                 * CLUSTER_ADMIN
                 * CLUSTER_OPERATOR_WRITER
                 * CLUSTER_DEVELOPER
                 * CLUSTER_CREATOR
                 * FOLDER_ADMIN
                 * FOLDER_MOVER
        :param pulumi.Input[str] resource_id: ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "role_name", role_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        """
        Type of resource. Allowed values are: 
          * ORGANIZATION
          * CLUSTER
          * FOLDER
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Name of the role to grant. Allowed values are:
          * BILLING_COORDINATOR
          * ORG_ADMIN
          * ORG_MEMBER
          * CLUSTER_ADMIN
          * CLUSTER_OPERATOR_WRITER
          * CLUSTER_DEVELOPER
          * CLUSTER_CREATOR
          * FOLDER_ADMIN
          * FOLDER_MOVER
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the resource. Required if the resource_type is 'FOLDER' or 'CLUSTER'. It should be omitted otherwise.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


