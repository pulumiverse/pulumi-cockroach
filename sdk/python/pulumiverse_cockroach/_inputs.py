# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ApiOidcConfigIdentityMapArgs',
    'ClusterDedicatedArgs',
    'ClusterRegionArgs',
    'ClusterServerlessArgs',
    'ClusterServerlessUsageLimitsArgs',
    'CmekAdditionalRegionArgs',
    'CmekRegionArgs',
    'CmekRegionKeyArgs',
    'LogExportConfigGroupArgs',
    'PrivateEndpointServicesServiceArgs',
    'PrivateEndpointServicesServiceAwsArgs',
    'UserRoleGrantsRoleArgs',
]

@pulumi.input_type
class ApiOidcConfigIdentityMapArgs:
    def __init__(__self__, *,
                 cc_identity: pulumi.Input[str],
                 token_identity: pulumi.Input[str],
                 is_regex: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cc_identity: The username (email or service account id) of the CC user that the token should map to.
        :param pulumi.Input[str] token_identity: The token value that needs to be mapped.
        :param pulumi.Input[bool] is_regex: Indicates that the token_principal field is a regex value.
        """
        pulumi.set(__self__, "cc_identity", cc_identity)
        pulumi.set(__self__, "token_identity", token_identity)
        if is_regex is not None:
            pulumi.set(__self__, "is_regex", is_regex)

    @property
    @pulumi.getter(name="ccIdentity")
    def cc_identity(self) -> pulumi.Input[str]:
        """
        The username (email or service account id) of the CC user that the token should map to.
        """
        return pulumi.get(self, "cc_identity")

    @cc_identity.setter
    def cc_identity(self, value: pulumi.Input[str]):
        pulumi.set(self, "cc_identity", value)

    @property
    @pulumi.getter(name="tokenIdentity")
    def token_identity(self) -> pulumi.Input[str]:
        """
        The token value that needs to be mapped.
        """
        return pulumi.get(self, "token_identity")

    @token_identity.setter
    def token_identity(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_identity", value)

    @property
    @pulumi.getter(name="isRegex")
    def is_regex(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that the token_principal field is a regex value.
        """
        return pulumi.get(self, "is_regex")

    @is_regex.setter
    def is_regex(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_regex", value)


@pulumi.input_type
class ClusterDedicatedArgs:
    def __init__(__self__, *,
                 disk_iops: Optional[pulumi.Input[int]] = None,
                 machine_type: Optional[pulumi.Input[str]] = None,
                 memory_gib: Optional[pulumi.Input[float]] = None,
                 num_virtual_cpus: Optional[pulumi.Input[int]] = None,
                 private_network_visibility: Optional[pulumi.Input[bool]] = None,
                 storage_gib: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disk_iops: Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        :param pulumi.Input[str] machine_type: Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4.
        :param pulumi.Input[float] memory_gib: Memory per node in GiB.
        :param pulumi.Input[int] num_virtual_cpus: Number of virtual CPUs per node in the cluster.
        :param pulumi.Input[bool] private_network_visibility: Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features.
        :param pulumi.Input[int] storage_gib: Storage amount per node in GiB.
        """
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if memory_gib is not None:
            pulumi.set(__self__, "memory_gib", memory_gib)
        if num_virtual_cpus is not None:
            pulumi.set(__self__, "num_virtual_cpus", num_virtual_cpus)
        if private_network_visibility is not None:
            pulumi.set(__self__, "private_network_visibility", private_network_visibility)
        if storage_gib is not None:
            pulumi.set(__self__, "storage_gib", storage_gib)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Number of disk I/O operations per second that are permitted on each node in the cluster. Zero indicates the cloud provider-specific default.
        """
        return pulumi.get(self, "disk_iops")

    @disk_iops.setter
    def disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_iops", value)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[str]]:
        """
        Machine type identifier within the given cloud provider, e.g., m6.xlarge, n2-standard-4.
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_type", value)

    @property
    @pulumi.getter(name="memoryGib")
    def memory_gib(self) -> Optional[pulumi.Input[float]]:
        """
        Memory per node in GiB.
        """
        return pulumi.get(self, "memory_gib")

    @memory_gib.setter
    def memory_gib(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_gib", value)

    @property
    @pulumi.getter(name="numVirtualCpus")
    def num_virtual_cpus(self) -> Optional[pulumi.Input[int]]:
        """
        Number of virtual CPUs per node in the cluster.
        """
        return pulumi.get(self, "num_virtual_cpus")

    @num_virtual_cpus.setter
    def num_virtual_cpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_virtual_cpus", value)

    @property
    @pulumi.getter(name="privateNetworkVisibility")
    def private_network_visibility(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to assign private IP addresses to nodes. Required for CMEK and other advanced networking features.
        """
        return pulumi.get(self, "private_network_visibility")

    @private_network_visibility.setter
    def private_network_visibility(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_network_visibility", value)

    @property
    @pulumi.getter(name="storageGib")
    def storage_gib(self) -> Optional[pulumi.Input[int]]:
        """
        Storage amount per node in GiB.
        """
        return pulumi.get(self, "storage_gib")

    @storage_gib.setter
    def storage_gib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage_gib", value)


@pulumi.input_type
class ClusterRegionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 internal_dns: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 sql_dns: Optional[pulumi.Input[str]] = None,
                 ui_dns: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the region. Should match the region code used by the cluster's cloud provider.
        :param pulumi.Input[str] internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param pulumi.Input[int] node_count: Number of nodes in the region. Will always be 0 for serverless clusters.
        :param pulumi.Input[bool] primary: Set to true to mark this region as the primary for a Serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        :param pulumi.Input[str] sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param pulumi.Input[str] ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "name", name)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if sql_dns is not None:
            pulumi.set(__self__, "sql_dns", sql_dns)
        if ui_dns is not None:
            pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[pulumi.Input[str]]:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @internal_dns.setter
    def internal_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_dns", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to mark this region as the primary for a Serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @sql_dns.setter
    def sql_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_dns", value)

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")

    @ui_dns.setter
    def ui_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ui_dns", value)


@pulumi.input_type
class ClusterServerlessArgs:
    def __init__(__self__, *,
                 routing_id: Optional[pulumi.Input[str]] = None,
                 spend_limit: Optional[pulumi.Input[int]] = None,
                 usage_limits: Optional[pulumi.Input['ClusterServerlessUsageLimitsArgs']] = None):
        """
        :param pulumi.Input[str] routing_id: Cluster identifier in a connection string.
        :param pulumi.Input[int] spend_limit: Spend limit in US cents.
        """
        if routing_id is not None:
            pulumi.set(__self__, "routing_id", routing_id)
        if spend_limit is not None:
            pulumi.set(__self__, "spend_limit", spend_limit)
        if usage_limits is not None:
            pulumi.set(__self__, "usage_limits", usage_limits)

    @property
    @pulumi.getter(name="routingId")
    def routing_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster identifier in a connection string.
        """
        return pulumi.get(self, "routing_id")

    @routing_id.setter
    def routing_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_id", value)

    @property
    @pulumi.getter(name="spendLimit")
    def spend_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Spend limit in US cents.
        """
        return pulumi.get(self, "spend_limit")

    @spend_limit.setter
    def spend_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spend_limit", value)

    @property
    @pulumi.getter(name="usageLimits")
    def usage_limits(self) -> Optional[pulumi.Input['ClusterServerlessUsageLimitsArgs']]:
        return pulumi.get(self, "usage_limits")

    @usage_limits.setter
    def usage_limits(self, value: Optional[pulumi.Input['ClusterServerlessUsageLimitsArgs']]):
        pulumi.set(self, "usage_limits", value)


@pulumi.input_type
class ClusterServerlessUsageLimitsArgs:
    def __init__(__self__, *,
                 request_unit_limit: pulumi.Input[int],
                 storage_mib_limit: pulumi.Input[int]):
        """
        :param pulumi.Input[int] request_unit_limit: Maximum number of Request Units that the cluster can consume during the month.
        :param pulumi.Input[int] storage_mib_limit: Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        pulumi.set(__self__, "request_unit_limit", request_unit_limit)
        pulumi.set(__self__, "storage_mib_limit", storage_mib_limit)

    @property
    @pulumi.getter(name="requestUnitLimit")
    def request_unit_limit(self) -> pulumi.Input[int]:
        """
        Maximum number of Request Units that the cluster can consume during the month.
        """
        return pulumi.get(self, "request_unit_limit")

    @request_unit_limit.setter
    def request_unit_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "request_unit_limit", value)

    @property
    @pulumi.getter(name="storageMibLimit")
    def storage_mib_limit(self) -> pulumi.Input[int]:
        """
        Maximum amount of storage (in MiB) that the cluster can have at any time during the month.
        """
        return pulumi.get(self, "storage_mib_limit")

    @storage_mib_limit.setter
    def storage_mib_limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "storage_mib_limit", value)


@pulumi.input_type
class CmekAdditionalRegionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 internal_dns: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 sql_dns: Optional[pulumi.Input[str]] = None,
                 ui_dns: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the region. Should match the region code used by the cluster's cloud provider.
        :param pulumi.Input[str] internal_dns: Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        :param pulumi.Input[int] node_count: Number of nodes in the region. Will always be 0 for serverless clusters.
        :param pulumi.Input[bool] primary: Set to true to mark this region as the primary for a Serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        :param pulumi.Input[str] sql_dns: DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        :param pulumi.Input[str] ui_dns: DNS name used when connecting to the DB Console for the cluster.
        """
        pulumi.set(__self__, "name", name)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if sql_dns is not None:
            pulumi.set(__self__, "sql_dns", sql_dns)
        if ui_dns is not None:
            pulumi.set(__self__, "ui_dns", ui_dns)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the region. Should match the region code used by the cluster's cloud provider.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[pulumi.Input[str]]:
        """
        Internal DNS name of the cluster within the cloud provider's network. Used to connect to the cluster with PrivateLink or VPC peering.
        """
        return pulumi.get(self, "internal_dns")

    @internal_dns.setter
    def internal_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_dns", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of nodes in the region. Will always be 0 for serverless clusters.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true to mark this region as the primary for a Serverless cluster. Exactly one region must be primary. Dedicated clusters expect to have no primary region.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="sqlDns")
    def sql_dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name of the cluster's SQL interface. Used to connect to the cluster with IP allowlisting.
        """
        return pulumi.get(self, "sql_dns")

    @sql_dns.setter
    def sql_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_dns", value)

    @property
    @pulumi.getter(name="uiDns")
    def ui_dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name used when connecting to the DB Console for the cluster.
        """
        return pulumi.get(self, "ui_dns")

    @ui_dns.setter
    def ui_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ui_dns", value)


@pulumi.input_type
class CmekRegionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input['CmekRegionKeyArgs'],
                 region: pulumi.Input[str],
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: Cloud provider region code.
        :param pulumi.Input[str] status: Describes the status of the current encryption key within the region.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input['CmekRegionKeyArgs']:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input['CmekRegionKeyArgs']):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Cloud provider region code.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the status of the current encryption key within the region.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class CmekRegionKeyArgs:
    def __init__(__self__, *,
                 auth_principal: pulumi.Input[str],
                 type: pulumi.Input[str],
                 uri: pulumi.Input[str],
                 created_at: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None,
                 user_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_principal: Principal to authenticate as in order to access the key.
        :param pulumi.Input[str] type: Type of encryption key. Current allowed values are:
                 * AWS_KMS
                 * GCP_CLOUD_KMS
                 * NULL_KMS
        :param pulumi.Input[str] uri: Provider-specific URI pointing to the encryption key.
        :param pulumi.Input[str] created_at: Indicates when the key was created.
        :param pulumi.Input[str] status: Current status of this key.
        :param pulumi.Input[str] updated_at: Indicates when the key was last updated.
        :param pulumi.Input[str] user_message: Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
        pulumi.set(__self__, "auth_principal", auth_principal)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "uri", uri)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_message is not None:
            pulumi.set(__self__, "user_message", user_message)

    @property
    @pulumi.getter(name="authPrincipal")
    def auth_principal(self) -> pulumi.Input[str]:
        """
        Principal to authenticate as in order to access the key.
        """
        return pulumi.get(self, "auth_principal")

    @auth_principal.setter
    def auth_principal(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_principal", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of encryption key. Current allowed values are:
          * AWS_KMS
          * GCP_CLOUD_KMS
          * NULL_KMS
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Provider-specific URI pointing to the encryption key.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates when the key was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Current status of this key.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates when the key was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="userMessage")
    def user_message(self) -> Optional[pulumi.Input[str]]:
        """
        Elaborates on the key's status and hints at how to fix issues that may have occurred during asynchronous key operations.
        """
        return pulumi.get(self, "user_message")

    @user_message.setter
    def user_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_message", value)


@pulumi.input_type
class LogExportConfigGroupArgs:
    def __init__(__self__, *,
                 channels: pulumi.Input[Sequence[pulumi.Input[str]]],
                 log_name: pulumi.Input[str],
                 min_level: Optional[pulumi.Input[str]] = None,
                 redact: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] channels: A list of CockroachDB log channels to include in this group.
        :param pulumi.Input[str] log_name: The name of the group, reflected in the log sink.
        :param pulumi.Input[str] min_level: The minimum log level to filter to this log group.
        :param pulumi.Input[bool] redact: Governs whether this log group should aggregate redacted logs if unset.
        """
        pulumi.set(__self__, "channels", channels)
        pulumi.set(__self__, "log_name", log_name)
        if min_level is not None:
            pulumi.set(__self__, "min_level", min_level)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)

    @property
    @pulumi.getter
    def channels(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of CockroachDB log channels to include in this group.
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter(name="logName")
    def log_name(self) -> pulumi.Input[str]:
        """
        The name of the group, reflected in the log sink.
        """
        return pulumi.get(self, "log_name")

    @log_name.setter
    def log_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_name", value)

    @property
    @pulumi.getter(name="minLevel")
    def min_level(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum log level to filter to this log group.
        """
        return pulumi.get(self, "min_level")

    @min_level.setter
    def min_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_level", value)

    @property
    @pulumi.getter
    def redact(self) -> Optional[pulumi.Input[bool]]:
        """
        Governs whether this log group should aggregate redacted logs if unset.
        """
        return pulumi.get(self, "redact")

    @redact.setter
    def redact(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "redact", value)


@pulumi.input_type
class PrivateEndpointServicesServiceArgs:
    def __init__(__self__, *,
                 aws: Optional[pulumi.Input['PrivateEndpointServicesServiceAwsArgs']] = None,
                 cloud_provider: Optional[pulumi.Input[str]] = None,
                 region_name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_provider: Cloud provider associated with this service.
        :param pulumi.Input[str] region_name: Cloud provider region code associated with this service.
        :param pulumi.Input[str] status: Operation status of the service.
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def aws(self) -> Optional[pulumi.Input['PrivateEndpointServicesServiceAwsArgs']]:
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['PrivateEndpointServicesServiceAwsArgs']]):
        pulumi.set(self, "aws", value)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud provider associated with this service.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud provider region code associated with this service.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Operation status of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class PrivateEndpointServicesServiceAwsArgs:
    def __init__(__self__, *,
                 availability_zone_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_id: Optional[pulumi.Input[str]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zone_ids: AZ IDs users should create their VPCs in to minimize their cost.
        :param pulumi.Input[str] service_id: Server side ID of the PrivateLink connection.
        :param pulumi.Input[str] service_name: AWS service name used to create endpoints.
        """
        if availability_zone_ids is not None:
            pulumi.set(__self__, "availability_zone_ids", availability_zone_ids)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="availabilityZoneIds")
    def availability_zone_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AZ IDs users should create their VPCs in to minimize their cost.
        """
        return pulumi.get(self, "availability_zone_ids")

    @availability_zone_ids.setter
    def availability_zone_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zone_ids", value)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[str]]:
        """
        Server side ID of the PrivateLink connection.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_id", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        AWS service name used to create endpoints.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


@pulumi.input_type
class UserRoleGrantsRoleArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[str],
                 role_name: pulumi.Input[str],
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_type: Type of resource. Allowed values are: 
                 * ORGANIZATION
                 * CLUSTER
                 * FOLDER
        :param pulumi.Input[str] role_name: Name of the role to grant. Allowed values are:
                 * DEVELOPER
                 * ADMIN
                 * BILLING_COORDINATOR
                 * ORG_ADMIN
                 * ORG_MEMBER
                 * CLUSTER_ADMIN
                 * CLUSTER_OPERATOR_WRITER
                 * CLUSTER_DEVELOPER
                 * CLUSTER_CREATOR
                 * FOLDER_ADMIN
                 * FOLDER_MOVER
        :param pulumi.Input[str] resource_id: ID of the resource. Omit if resource_type is 'ORGANIZATION'.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "role_name", role_name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        """
        Type of resource. Allowed values are: 
          * ORGANIZATION
          * CLUSTER
          * FOLDER
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Name of the role to grant. Allowed values are:
          * DEVELOPER
          * ADMIN
          * BILLING_COORDINATOR
          * ORG_ADMIN
          * ORG_MEMBER
          * CLUSTER_ADMIN
          * CLUSTER_OPERATOR_WRITER
          * CLUSTER_DEVELOPER
          * CLUSTER_CREATOR
          * FOLDER_ADMIN
          * FOLDER_MOVER
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the resource. Omit if resource_type is 'ORGANIZATION'.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


