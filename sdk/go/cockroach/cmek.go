// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package cockroach

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-cockroach/sdk/go/cockroach/internal"
)

// Customer-managed encryption keys (CMEK) resource for a single cluster.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-cockroach/sdk/go/cockroach"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := cockroach.NewCmek(ctx, "advanced", &cockroach.CmekArgs{
//				ClusterId: pulumi.Any(advancedCockroachCluster.Id),
//				Regions: cockroach.CmekRegionArray{
//					&cockroach.CmekRegionArgs{
//						Region: pulumi.String("us-central-1"),
//						Key: &cockroach.CmekRegionKeyArgs{
//							AuthPrincipal: pulumi.String("arn:aws:iam::account:role/role-name-with-path"),
//							Type:          pulumi.String("AWS_KMS"),
//							Uri:           pulumi.String("arn:aws:kms:us-west-2:111122223333:key/id-of-kms-key"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// format: <cluster id>
//
// ```sh
// $ pulumi import cockroach:index/cmek:Cmek advanced 1f69fdd2-600a-4cfc-a9ba-16995df0d77d
// ```
type Cmek struct {
	pulumi.CustomResourceState

	// Once CMEK is enabled for a cluster, no new regions can be added to the cluster resource, since they need encryption key
	// info stored in the CMEK resource. New regions can be added and maintained here instead.
	AdditionalRegions CmekAdditionalRegionArrayOutput `pulumi:"additionalRegions"`
	// Cluster ID.
	ClusterId pulumi.StringOutput   `pulumi:"clusterId"`
	Regions   CmekRegionArrayOutput `pulumi:"regions"`
	// Aggregated status of the cluster's encryption key(s).
	Status pulumi.StringOutput `pulumi:"status"`
}

// NewCmek registers a new resource with the given unique name, arguments, and options.
func NewCmek(ctx *pulumi.Context,
	name string, args *CmekArgs, opts ...pulumi.ResourceOption) (*Cmek, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.Regions == nil {
		return nil, errors.New("invalid value for required argument 'Regions'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Cmek
	err := ctx.RegisterResource("cockroach:index/cmek:Cmek", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCmek gets an existing Cmek resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCmek(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CmekState, opts ...pulumi.ResourceOption) (*Cmek, error) {
	var resource Cmek
	err := ctx.ReadResource("cockroach:index/cmek:Cmek", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Cmek resources.
type cmekState struct {
	// Once CMEK is enabled for a cluster, no new regions can be added to the cluster resource, since they need encryption key
	// info stored in the CMEK resource. New regions can be added and maintained here instead.
	AdditionalRegions []CmekAdditionalRegion `pulumi:"additionalRegions"`
	// Cluster ID.
	ClusterId *string      `pulumi:"clusterId"`
	Regions   []CmekRegion `pulumi:"regions"`
	// Aggregated status of the cluster's encryption key(s).
	Status *string `pulumi:"status"`
}

type CmekState struct {
	// Once CMEK is enabled for a cluster, no new regions can be added to the cluster resource, since they need encryption key
	// info stored in the CMEK resource. New regions can be added and maintained here instead.
	AdditionalRegions CmekAdditionalRegionArrayInput
	// Cluster ID.
	ClusterId pulumi.StringPtrInput
	Regions   CmekRegionArrayInput
	// Aggregated status of the cluster's encryption key(s).
	Status pulumi.StringPtrInput
}

func (CmekState) ElementType() reflect.Type {
	return reflect.TypeOf((*cmekState)(nil)).Elem()
}

type cmekArgs struct {
	// Once CMEK is enabled for a cluster, no new regions can be added to the cluster resource, since they need encryption key
	// info stored in the CMEK resource. New regions can be added and maintained here instead.
	AdditionalRegions []CmekAdditionalRegion `pulumi:"additionalRegions"`
	// Cluster ID.
	ClusterId string       `pulumi:"clusterId"`
	Regions   []CmekRegion `pulumi:"regions"`
	// Aggregated status of the cluster's encryption key(s).
	Status *string `pulumi:"status"`
}

// The set of arguments for constructing a Cmek resource.
type CmekArgs struct {
	// Once CMEK is enabled for a cluster, no new regions can be added to the cluster resource, since they need encryption key
	// info stored in the CMEK resource. New regions can be added and maintained here instead.
	AdditionalRegions CmekAdditionalRegionArrayInput
	// Cluster ID.
	ClusterId pulumi.StringInput
	Regions   CmekRegionArrayInput
	// Aggregated status of the cluster's encryption key(s).
	Status pulumi.StringPtrInput
}

func (CmekArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cmekArgs)(nil)).Elem()
}

type CmekInput interface {
	pulumi.Input

	ToCmekOutput() CmekOutput
	ToCmekOutputWithContext(ctx context.Context) CmekOutput
}

func (*Cmek) ElementType() reflect.Type {
	return reflect.TypeOf((**Cmek)(nil)).Elem()
}

func (i *Cmek) ToCmekOutput() CmekOutput {
	return i.ToCmekOutputWithContext(context.Background())
}

func (i *Cmek) ToCmekOutputWithContext(ctx context.Context) CmekOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CmekOutput)
}

// CmekArrayInput is an input type that accepts CmekArray and CmekArrayOutput values.
// You can construct a concrete instance of `CmekArrayInput` via:
//
//	CmekArray{ CmekArgs{...} }
type CmekArrayInput interface {
	pulumi.Input

	ToCmekArrayOutput() CmekArrayOutput
	ToCmekArrayOutputWithContext(context.Context) CmekArrayOutput
}

type CmekArray []CmekInput

func (CmekArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cmek)(nil)).Elem()
}

func (i CmekArray) ToCmekArrayOutput() CmekArrayOutput {
	return i.ToCmekArrayOutputWithContext(context.Background())
}

func (i CmekArray) ToCmekArrayOutputWithContext(ctx context.Context) CmekArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CmekArrayOutput)
}

// CmekMapInput is an input type that accepts CmekMap and CmekMapOutput values.
// You can construct a concrete instance of `CmekMapInput` via:
//
//	CmekMap{ "key": CmekArgs{...} }
type CmekMapInput interface {
	pulumi.Input

	ToCmekMapOutput() CmekMapOutput
	ToCmekMapOutputWithContext(context.Context) CmekMapOutput
}

type CmekMap map[string]CmekInput

func (CmekMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cmek)(nil)).Elem()
}

func (i CmekMap) ToCmekMapOutput() CmekMapOutput {
	return i.ToCmekMapOutputWithContext(context.Background())
}

func (i CmekMap) ToCmekMapOutputWithContext(ctx context.Context) CmekMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CmekMapOutput)
}

type CmekOutput struct{ *pulumi.OutputState }

func (CmekOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Cmek)(nil)).Elem()
}

func (o CmekOutput) ToCmekOutput() CmekOutput {
	return o
}

func (o CmekOutput) ToCmekOutputWithContext(ctx context.Context) CmekOutput {
	return o
}

// Once CMEK is enabled for a cluster, no new regions can be added to the cluster resource, since they need encryption key
// info stored in the CMEK resource. New regions can be added and maintained here instead.
func (o CmekOutput) AdditionalRegions() CmekAdditionalRegionArrayOutput {
	return o.ApplyT(func(v *Cmek) CmekAdditionalRegionArrayOutput { return v.AdditionalRegions }).(CmekAdditionalRegionArrayOutput)
}

// Cluster ID.
func (o CmekOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *Cmek) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

func (o CmekOutput) Regions() CmekRegionArrayOutput {
	return o.ApplyT(func(v *Cmek) CmekRegionArrayOutput { return v.Regions }).(CmekRegionArrayOutput)
}

// Aggregated status of the cluster's encryption key(s).
func (o CmekOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Cmek) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

type CmekArrayOutput struct{ *pulumi.OutputState }

func (CmekArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Cmek)(nil)).Elem()
}

func (o CmekArrayOutput) ToCmekArrayOutput() CmekArrayOutput {
	return o
}

func (o CmekArrayOutput) ToCmekArrayOutputWithContext(ctx context.Context) CmekArrayOutput {
	return o
}

func (o CmekArrayOutput) Index(i pulumi.IntInput) CmekOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Cmek {
		return vs[0].([]*Cmek)[vs[1].(int)]
	}).(CmekOutput)
}

type CmekMapOutput struct{ *pulumi.OutputState }

func (CmekMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Cmek)(nil)).Elem()
}

func (o CmekMapOutput) ToCmekMapOutput() CmekMapOutput {
	return o
}

func (o CmekMapOutput) ToCmekMapOutputWithContext(ctx context.Context) CmekMapOutput {
	return o
}

func (o CmekMapOutput) MapIndex(k pulumi.StringInput) CmekOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Cmek {
		return vs[0].(map[string]*Cmek)[vs[1].(string)]
	}).(CmekOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CmekInput)(nil)).Elem(), &Cmek{})
	pulumi.RegisterInputType(reflect.TypeOf((*CmekArrayInput)(nil)).Elem(), CmekArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CmekMapInput)(nil)).Elem(), CmekMap{})
	pulumi.RegisterOutputType(CmekOutput{})
	pulumi.RegisterOutputType(CmekArrayOutput{})
	pulumi.RegisterOutputType(CmekMapOutput{})
}
